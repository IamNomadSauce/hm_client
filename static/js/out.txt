// chart_render.js

window.hoveredPoint = null
window.point = null
window.hoveredTrendline = null
window.hoveredTrendlinePoint = null
window.hoveredSubtrendPoint = null
window.trendlinePoints = []
window.subtrendPoints = []
window.trendstartlines = []
window.currentTrendlines = [] window.trendlines || []
window.trendlinePath = []
var price = 0.0

window.canvas = document.getElementById('candlestickChart');
window.ctx = canvas.getContext('2d');

window.chartState = null;

window.updateChartState = function (ctx, width, height, margin, minPrice, maxPrice, firstCandleTime, lastCandleTime, trendlines) {
    chartState = {
        ctx,
        width,
        height,
        margin,
        minPrice,
        maxPrice,
        firstCandleTime,
        lastCandleTime,
        trendlines
    }
}

window.drawCandlestickChart = function (data, start, end) {
    // console.log("DrawCandlestickChart\n", data, start, end)
    // console.log(data, start, end)
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const width = canvas.width;
    const height = canvas.height;
    const margin = 50;

    const visibleData = data.slice(start, end);
    // let visibleData = data
    const candleWidth = (width - 2 * margin) / visibleData.length;
    const firstCandleTime = visibleData[0].Timestamp;
    const lastCandleTime = visibleData[visibleData.length - 1].Timestamp;
    const timeRange = lastCandleTime - firstCandleTime;

    const minPrice = Math.min(...visibleData.map(d => d.Low));
    const maxPrice = Math.max(...visibleData.map(d => d.High));

    window.updateChartState(ctx, width, height, margin, minPrice, maxPrice, firstCandleTime, lastCandleTime, window.currentTrendlines);

    // Draw candles
    visibleData.forEach((d, i) => {
        const x = margin + i * candleWidth;
        const openY = height - margin - ((d.Open - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
        const closeY = height - margin - ((d.Close - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
        const highY = height - margin - ((d.High - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
        const lowY = height - margin - ((d.Low - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

        // Draw candlestick
        ctx.beginPath();
        ctx.moveTo(x + candleWidth / 2, highY);
        ctx.lineTo(x + candleWidth / 2, lowY);
        ctx.strokeStyle = 'gray';
        ctx.stroke();

        ctx.beginPath();
        ctx.rect(x, Math.min(openY, closeY), candleWidth, Math.abs(openY - closeY));
        ctx.fillStyle = d.Close >= d.Open ? 'green' : 'red';
        ctx.strokeStyle = 'black';
        ctx.fill();
        ctx.stroke();
    });

    // Draw fills
    if (current_fills) {
        current_fills.forEach(fill => {
            const fillTime = new Date(fill.time).getTime() / 1000;
            const firstCandleTime = visibleData[0].Timestamp;
            const timeRange = visibleData[visibleData.length - 1].Timestamp - firstCandleTime;
            const xPosition = margin + ((fillTime - firstCandleTime) / timeRange) * (width - 2 * margin);
            const fillY = height - margin - ((fill.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

            ctx.beginPath();
            ctx.arc(xPosition, fillY, 4, 0, 2 * Math.PI);
            ctx.fillStyle = fill.side.toLowerCase() === 'buy' ? 'lime' : 'red';
            ctx.fill();
        });
    }

    // Draw orders
    if (current_orders) {
        current_orders.forEach(order => {
            const orderY = height - margin - ((order.Price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
            ctx.beginPath();
            ctx.moveTo(margin, orderY);
            ctx.lineTo(width - margin, orderY);
            ctx.strokeStyle = order.Side.toLowerCase() === 'buy' ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
            ctx.stroke();
        });
    }

    // Draw trade groups
    tradeGroups = {};

    if (current_trades) {
        current_trades.forEach(trade => {
            if (!tradeGroups[trade.group_id]) {
                tradeGroups[trade.group_id] = [];
            }
            tradeGroups[trade.group_id].push(trade);
        });

        Object.values(tradeGroups).forEach(trades => {
            // Calculate Y positions for entry/stop/targets
            const entryY = height - margin - ((trades[0].entry_price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
            const stopY = height - margin - ((trades[0].stop_price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
            const ptYs = trades.map(trade =>
                height - margin - ((trade.pt_price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin)
            );

            // Draw entry line
            ctx.beginPath();
            ctx.moveTo(margin, entryY);
            ctx.lineTo(width - margin, entryY);
            ctx.strokeStyle = trades[0].entry_status === 'FILLED' ? 'rgba(0, 255, 0, 0.8)' : 'rgba(0, 255, 0, 0.5)';
            ctx.stroke();

            // Draw stop loss line
            ctx.beginPath();
            ctx.moveTo(margin, stopY);
            ctx.lineTo(width - margin, stopY);
            ctx.strokeStyle = trades[0].stop_status === 'FILLED' ? 'rgba(255, 0, 0, 0.8)' : 'rgba(255, 0, 0, 0.5)';
            ctx.stroke();

            // Draw profit target lines
            trades.forEach((trade, i) => {
                const ptY = ptYs[i];
                ctx.beginPath();
                ctx.moveTo(margin, ptY);
                ctx.lineTo(width - margin, ptY);
                ctx.strokeStyle = trade.pt_status === 'FILLED' ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 255, 0, 0.5)';
                ctx.stroke();
            });

            // Draw connecting lines between targets
            ctx.beginPath();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ptYs.forEach((ptY, i) => {
                if (i > 0) {
                    ctx.moveTo(margin, ptYs[i - 1]);
                    ctx.lineTo(width - margin, ptY);
                }
            });
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw R:R ratios
            trades.forEach((trade, i) => {
                const ptY = ptYs[i];
                const riskAmount = Math.abs(trade.entry_price - trade.stop_price);
                const rewardAmount = Math.abs(trade.pt_price - trade.entry_price);
                const rrRatio = (rewardAmount / riskAmount).toFixed(2);

                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(`R:R ${rrRatio}`, width - 80, ptY - 5);
            });
        });
    }

    // Draw triggers
    if (window.current_triggers) {
        window.current_triggers.forEach(trigger => {
            // Skip triggered triggers
            if (trigger.status === 'triggered') {
                return;
            }

            const triggerY = height - margin - ((trigger.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

            // Draw the trigger line
            ctx.beginPath();
            ctx.moveTo(margin, triggerY);
            ctx.lineTo(width - margin, triggerY);
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#b87100';
            ctx.stroke();
            ctx.setLineDash([]);

            // Add label
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            const triggerType = trigger.type
            ctx.fillText(`${triggerType}: ${trigger.price.toFixed(8)}`, width - 200, triggerY - 5);
        });
    }

    // Draw trends and metatrends
    if (chartState.trendlines && window.meta_trends_toggle) {
        trendlinePoints = []; // Reset points array each redraw
        subtrendPoints = [];

        chartState.trendlines.forEach((trendline, index) => {
            // Draw subtrends
            // trendline.trends.forEach(subtrend => {
            //     const startX = margin + ((subtrend.start.time - firstCandleTime) / timeRange) * (width - 2 * margin);
            //     const endX = margin + ((subtrend.end.time - firstCandleTime) / timeRange) * (width - 2 * margin);
            //     const startY = height - margin - ((subtrend.start.point - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
            //     const endY = height - margin - ((subtrend.end.point - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
            //
            //     ctx.beginPath();
            //     ctx.moveTo(startX, startY);
            //     ctx.lineTo(endX, endY);
            //     ctx.strokeStyle = subtrend.status === "done" ? "gray" : "gray";
            //     ctx.lineWidth = 2;
            //     ctx.stroke();
            //
            //     // Draw start point
            //     const isStartHovered = window.hoveredSubtrendPoint && window.hoveredSubtrendPoint.trend === subtrend && window.hoveredSubtrendPoint.type === 'start';
            //     ctx.beginPath();
            //     ctx.arc(startX, startY, isStartHovered ? 8 : 4, 0, 2 * Math.PI);
            //     ctx.fillStyle = 'gold';
            //     ctx.fill();
            //
            //     // Draw end point
            //     const isEndHovered = window.hoveredSubtrendPoint && window.hoveredSubtrendPoint.trend === subtrend && window.hoveredSubtrendPoint.type === 'end';
            //     ctx.beginPath();
            //     ctx.arc(endX, endY, isEndHovered ? 8 : 4, 0, 2 * Math.PI);
            //     ctx.fillStyle = 'white';
            //     ctx.fill();
            //
            //     // Store subtrend points with explicit price
            //     if (startX >= margin && startX <= width - margin && startY >= margin && startY <= height - margin) {
            //         subtrendPoints.push({
            //             x: startX,
            //             y: startY,
            //             trend: subtrend, // Reference to the subtrend object
            //             index: index,
            //             type: 'start',
            //             price: subtrend.start.point // Explicitly store the subtrend’s start price
            //         });
            //     }
            //     if (endX >= margin && endX <= width - margin && endY >= margin && endY <= height - margin) {
            //         subtrendPoints.push({
            //             x: endX,
            //             y: endY,
            //             trend: subtrend,
            //             index: index,
            //             type: 'end',
            //             price: subtrend.end.point // Explicitly store the subtrend’s end price
            //         });
            //     }
            // });

            // Draw main trendline
            const startX = margin + ((trendline.start.time - firstCandleTime) / timeRange) * (width - 2 * margin);
            const endX = margin + ((trendline.end.time - firstCandleTime) / timeRange) * (width - 2 * margin);
            const startY = height - margin - ((trendline.start.point - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
            const endY = height - margin - ((trendline.end.point - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = trendline.status === "done" ? "gray" : "gold";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw start point
            const isStartHovered = window.hoveredTrendlinePoint && window.hoveredTrendlinePoint.trend === trendline && window.hoveredTrendlinePoint.type === 'start';
            ctx.beginPath();
            ctx.arc(startX, startY, isStartHovered ? 8 : 4, 0, 2 * Math.PI);
            ctx.fillStyle = 'gold';
            ctx.fill();

            // Draw end point
            const isEndHovered = window.hoveredTrendlinePoint && window.hoveredTrendlinePoint.trend === trendline && window.hoveredTrendlinePoint.type === 'end';
            ctx.beginPath();
            ctx.arc(endX, endY, isEndHovered ? 8 : 4, 0, 2 * Math.PI);
            ctx.fillStyle = 'white';
            ctx.fill();

            // Store main trendline points with explicit price
            if (startX >= margin && startX <= width - margin && startY >= margin && startY <= height - margin) {
                trendlinePoints.push({
                    x: startX,
                    y: startY,
                    trend: trendline, // Reference to the main trendline object
                    index: index,
                    type: 'start',
                    price: trendline.start.point // Explicitly store the main trendline’s start price
                });
            }
            if (endX >= margin && endX <= width - margin && endY >= margin && endY <= height - margin) {
                trendlinePoints.push({
                    x: endX,
                    y: endY,
                    trend: trendline,
                    index: index,
                    type: 'end',
                    price: trendline.end.point // Explicitly store the main trendline’s end price
                });
            }
        });
    }

    if (basetrends && window.base_trends_toggle) {

        // console.log("DX_Trendlines: ", dxtrendlines)

        trendlinePoints = []; // Reset points array each redraw
        basetrends.forEach((trendline, index) => {
            const startX = margin + ((trendline.start.time - firstCandleTime) / timeRange) * (width - 2 * margin);
            const endX = margin + ((trendline.end.time - firstCandleTime) / timeRange) * (width - 2 * margin);
            const startY = height - margin - ((trendline.start.point - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
            const endY = height - margin - ((trendline.end.point - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
            // console.log("Trendline", trendline)

            // Draw trendline
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = trendline.status == "done" ? "gray" : "gray";
            // ctx.strokeStyle = trendline.status == "done" ? (trendline.direction == "up" ? "green" : "red") : "gold";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Draw start point
            const isStartHovered = window.hoveredTrendlinePoint && window.hoveredTrendlinePoint.trendline === trendline && window.hoveredTrendlinePoint.type === 'start';
            ctx.beginPath();
            ctx.arc(startX, startY, isStartHovered ? 8 : 4, 0, 2 * Math.PI);
            ctx.fillStyle = trendline.end.color;
            ctx.fill();

            // Draw end point
            const isEndHovered = window.hoveredTrendlinePoint && window.hoveredTrendlinePoint.trendline === trendline && window.hoveredTrendlinePoint.type === 'end';
            ctx.beginPath();
            ctx.arc(endX, endY, isEndHovered ? 8 : 4, 0, 2 * Math.PI);
            ctx.fillStyle = trendline.end.color;
            ctx.fill();

            // Store points if within visible bounds
            if (startX >= margin && startX <= width - margin && startY >= margin && startY <= height - margin) {
                trendlinePoints.push({ x: startX, y: startY, trendline, index, type: 'start' });
            }
            if (endX >= margin && endX <= width - margin && endY >= margin && endY <= height - margin) {
                trendlinePoints.push({ x: endX, y: endY, trendline, index, type: 'end' });
            }
        });

        let last_trend = basetrends[basetrends.length - 1]
        // console.log("Last Trendline", last_trend)
    }

    // if (trendstartlines) {
    //     trendstartlines.forEach(subtrend => {
    //
    //         // console.log("|TREND|", trend)
    //         console.log("|TREND|",subtrend)
    //
    //
    //         const startX = margin + ((subtrend.start.time - firstCandleTime) / timeRange) * (width - 2 * margin);
    //         const endX = margin + ((subtrend.end.time - firstCandleTime) / timeRange) * (width - 2 * margin);
    //         const startY = height - margin - ((subtrend.start.point - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
    //         const endY = height - margin - ((subtrend.end.point - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
    //
    //         ctx.beginPath();
    //         ctx.moveTo(startX, startY);
    //         ctx.lineTo(endX, endY);
    //         ctx.strokeStyle = subtrend.status === "done" ? "gold" : "gold";
    //         ctx.lineWidth = 5;
    //         ctx.stroke();
    //
    //         // const trendY = height - margin - ((trend - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
    //         // ctx.beginPath();
    //         // ctx.moveTo(margin, trendY);
    //         // ctx.lineTo(width - margin, trendY);
    //         // ctx.strokeStyle = 'rgba(100,100,100,0.5)';
    //         // ctx.stroke();
    //     })
    // }
	
    drawToolbar(ctx, width, height, margin, minPrice, maxPrice);
    drawCrosshair(ctx, width, height, margin, minPrice, maxPrice);

    return { ctx, width, height, margin, minPrice, maxPrice };
}

function drawCrosshair(ctx, width, height, margin, minPrice, maxPrice) {
    // Draw vertical line
    ctx.beginPath();
    ctx.moveTo(mouseX, margin);
    ctx.lineTo(mouseX, height - margin);
    ctx.strokeStyle = 'rgba(100,100,100,0.5)';
    ctx.stroke();

    // Draw horizontal line
    ctx.beginPath();
    ctx.moveTo(margin, mouseY);
    ctx.lineTo(width - margin, mouseY);
    ctx.strokeStyle = 'rgba(100,100,100,0.5)';
    ctx.stroke();

    // Calculate price - fixed formula to match the candlestick scaling
    price = minPrice + ((height - margin - mouseY) / (height - 2 * margin)) * (maxPrice - minPrice);
    ctx.fillStyle = 'white';
    ctx.fillText(price.toFixed(2), width - 40, mouseY - 5);
}

window.showPointMenu = function(x, y) {
    console.log("X", x)
    console.log("Y", y)
    console.log("Price", price)

    document.querySelectorAll('.chart-point-menu').forEach(el => el.remove())

    const menu = document.createElement('div')
    menu.className = 'trendline-point-menu';
    menu.style.position = 'absolute';
    menu.style.left = `${mouseX - 100}px`;
    menu.style.top = `${mouseY + 50}px`;
    menu.style.backgroundColor = '#333';
    menu.style.color = 'white';
    menu.style.padding = '10px';
    menu.style.border = '1px solid #666';
    menu.style.borderRadius = '4px';
    menu.style.display = 'block';
    menu.style.zIndex = '1000';
    menu.style.pointerEvents = 'auto';
    menu.style.minWidth = '150px';

    menu.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <strong>Point Menu</strong>
            <span class="close-menu" style="cursor: pointer; padding: 0 5px;">×</span>
        </div>
        <div class="line-menu-item" data-action="entry">Entry</div>
        <div class="line-menu-item" data-action="stop">Stop Loss</div>
        <div class="line-menu-item" data-action="pt">Profit Target</div>
        <div class="line-menu-item" data-action="trigger">Trigger</div>
    `;

    document.body.appendChild(menu);

    // Close menu when clicking the X button
    menu.querySelector('.close-menu').addEventListener('click', () => {
        menu.remove();
    });

    // Close menu when hovering off
    menu.addEventListener('mouseleave', () => {
        menu.remove();
    });

    menu.querySelectorAll('.line-menu-item').forEach(item => {
        item.addEventListener('click', function () {
            const action = this.dataset.action;
            const line = { price: price };
            handleLineAction(action, line);
            menu.remove();
            drawCandlestickChart(window.stockData, window.start, window.end);
        });
    });

    // Close menu when clicking outside
    const closeMenuOnOutsideClick = (event) => {
        if (!menu.contains(event.target) && !event.target.classList.contains('line-menu-item')) {
            menu.remove();
            document.removeEventListener('click', closeMenuOnOutsideClick);
        }
    };
    setTimeout(() => {
        document.addEventListener('click', closeMenuOnOutsideClick);
    }, 0);
}

function drawToolbar(ctx, width, height, margin, minPrice, maxPrice) {
    let activeLineIndex = -1;
    draw_lines.forEach((line, index) => {
        // Convert price back to Y coordinate
        const y = height - margin - ((line.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

        if (line.type === 'trigger') {
            ctx.setLineDash([5, 5])
        } else {
            ctx.setLineDash([])
        }

        ctx.beginPath();
        ctx.moveTo(margin, y);
        ctx.lineTo(width - margin, y);
        ctx.strokeStyle = line.color || 'yellow';
        ctx.stroke();

        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        if (line.type === 'trigger') {
            const lastCandle = stockData[stockData.length - 1]
            const currentPrice = lastCandle.Close
            const triggerType = line.price > currentPrice ? 'Trigger Above' : 'Trigger Below'
            ctx.fillText(`${triggerType}: ${line.price.toFixed(8)}`, width - 200, y - 5)
        } else {
            ctx.fillText(`${line.type ? line.type + ' - ' : ''}${line.price.toFixed(2)}`, width - 120, y - 5);
        }
    });

    if (currentTool === 'line' && drawingStart) {
        ctx.beginPath();
        ctx.moveTo(margin, drawingStart.y);
        ctx.lineTo(width - margin, drawingStart.y);
        ctx.strokeStyle = 'yellow';
        ctx.stroke();
    } else if (currentTool === 'box' && drawingStart) {
        ctx.beginPath();
        ctx.rect(drawingStart.x, drawingStart.y, mouseX - drawingStart.x, mouseY - drawingStart.y);
        ctx.strokeStyle = 'yellow';
        ctx.stroke();
    }
}
// event_handlers.js

window.mouseX = 0;
window.mouseY = 0;
window.currentTool = null
window.drawingStart = null
window.draw_boxes = []
window.draw_lines = []
window.activeLineIndex = -1;
current_triggers = []


window.setupEventListeners = function () {
    console.log("Setup Event Listeners")
    canvas.addEventListener('mousemove', function (event) {
        // console.log("MOUSE MOVE INIT")
        const rect = canvas.getBoundingClientRect();
        window.mouseX = event.clientX - rect.left;
        window.mouseY = event.clientY - rect.top;

        if (window.isDragging) {
            let dx = event.clientX - window.startX;
            let panFactor = Math.floor(dx / 10);
            if (panFactor !== 0) {
                window.start = Math.max(0, window.start - panFactor);
                window.end = Math.min(window.stockData.length, window.end - panFactor);
                window.startX = event.clientX;
                drawCandlestickChart(window.stockData, window.start, window.end);
            }
        } else {
            handleMouseMove(event, window.chartState, window.tradeGroups);
            drawCandlestickChart(window.stockData, window.start, window.end)
        }
    });


    canvas.addEventListener('mousedown', function (event) {
        var rect = canvas.getBoundingClientRect();
        mouseX = event.clientX - rect.left;
        mouseY = event.clientY - rect.top;

        console.log("Current Tool:", window.currentTool)
        if (window.currentTool) {
            if (window.currentTool === 'line' || window.currentTool === 'trigger') {
                chartState = drawCandlestickChart(window.stockData, window.start, window.end);
                const price = calculatePrice(mouseY, chartState.height, chartState.margin, chartState.minPrice, chartState.maxPrice);
                const line = { price: price };

                if (window.currentTool === 'trigger') {
                    const lastCandle = window.stockData[window.stockData.length - 1];
                    const currentPrice = lastCandle.Close;

                    line.type = 'trigger';
                    line.color = '#ff00ff';

                    const triggerData = {
                        product_id: selectedProduct.product_id,
                        type: line.price > currentPrice ? 'price_above' : 'price_below',
                        price: parseFloat(line.price),
                        status: 'active',
                        xch_id: exchange.ID
                    };

                    fetch('create-trigger', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(triggerData)
                    })
                        .then(response => response.json())
                        .then(data => {
                            console.log('2Trigger Created: ', data);
                            line.triggerId = data.id;
                        })
                        .catch(error => {
                            console.log('Error creating trigger:', error);
                        });
                }

                draw_lines.push(line);
                drawCandlestickChart(window.stockData, window.start, window.end);
            }
            drawingStart = { x: mouseX, y: mouseY };
        } else {
            isDragging = true;
            startX = event.clientX;
            canvas.style.cursor = 'grabbing';
        }
    });
}



const showTriggerNotification = function (trigger) {
    const notification = document.createElement('div')
    notification.className = 'trigger-notification'
    notification.innerHTML = `
      <div class="notification-content">
        <strong>${trigger.product_id}</strong>
      </div>
    `
    document.body.appendChild(notification)

    setTimeout(() => notification.remove(), 5000)
}


const triggerHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;
    let isNearTrigger = false;

    if (window.current_triggers) {
        window.current_triggers.forEach(trigger => {
            const triggerY = chartState.height - chartState.margin -
                ((trigger.price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
                (chartState.height - 2 * chartState.margin);
            if (isMouseNearLine(mouseY, triggerY)) {
                isNearTrigger = true;
            }
        });
    }
    return isNearTrigger;
};

window.triggerClickHandler = function (e, chartState) {
    // console.log("Trigger Click Handler")
    if (e.type !== 'click') return; // Only handle click events

    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    if (!window.current_triggers) return;

    let selectedTrigger = null;
    let triggerY = null;

    console.log("Current Triggers", current_triggers)

    // Find the closest trigger to the click
    window.current_triggers.forEach(trigger => {
        const y = chartState.height - chartState.margin -
            ((trigger.price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
            (chartState.height - 2 * chartState.margin);

        if (isMouseNearLine(mouseY, y)) {
            selectedTrigger = trigger;
            triggerY = y;
        }
    });

    // Remove any existing menu
    document.querySelectorAll('.trigger-menu').forEach(el => el.remove());

    console.log("Selected Trigger", selectedTrigger)

    // If a trigger was clicked, show the menu
    if (selectedTrigger) {
        const menu = document.createElement('div');
        menu.className = 'trigger-menu';
        menu.style.position = 'absolute';
        menu.style.left = `${e.pageX - 150}px`;
        menu.style.top = `${e.pageY - 10}px`;
        menu.style.backgroundColor = '#333';
        menu.style.color = 'white';
        menu.style.padding = '10px';
        menu.style.border = '1px solid #666';
        menu.style.borderRadius = '4px';
        menu.style.display = 'block';
        menu.style.zIndex = '1000';
        menu.style.pointerEvents = 'auto';
        menu.style.minWidth = '200px';

        menu.innerHTML = `
            <div style="margin-bottom: 8px;"><strong>Trigger Details</strong></div>
            <div>Type: ${selectedTrigger.type}</div>
            <div>Price: ${selectedTrigger.price.toFixed(8)}</div>
            <div>Status: ${selectedTrigger.status}</div>
            <div class="trigger-menu-item" onclick="editTrigger(${selectedTrigger.id}); document.querySelector('.trigger-menu').remove();">Edit</div>
            <div class="trigger-menu-item" onclick="deleteTrigger(${selectedTrigger.id}); document.querySelector('.trigger-menu').remove();">Delete</div>
            <div class="trigger-menu-item" onclick="handleTriggerAction('connect', ${selectedTrigger.id}); document.querySelector('.trigger-menu').remove();">Connect to Trade</div>
            <div class="trigger-menu-item" onclick="showTradeOptions(${selectedTrigger.id}); document.querySelector('.trigger-menu').remove();">Upon Trigger...</div>
        `;

        document.body.appendChild(menu);

        // Add a global click listener to close the menu when clicking outside
        const closeMenuOnOutsideClick = (event) => {
            if (!menu.contains(event.target) && !event.target.classList.contains('trigger-menu-item')) {
                menu.remove();
                document.removeEventListener('click', closeMenuOnOutsideClick);
            }
        };
        // Delay to avoid immediate closure from the current click
        setTimeout(() => {
            document.addEventListener('click', closeMenuOnOutsideClick);
        }, 0);
    }
};

function distanceToLineSegment(px, py, x1, y1, x2, y2) {

    const dx = x2 - x1
    const dy = y2 - y1
    if (dx === 0 && dy === 0) {
        return Math.hypot(px - x1, py - y1)
    }

    const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy)
    if (t < 0) {
        return Math.hypot(px - x1, py - y1)
    } else if (t > 1) {
        return Math.hypot(px - x2, py - y2)
    } else {
        const nx = x1 + t * dx
        const ny = y1 + t * dy
        return Math.hypot(px - nx, py - ny)
    }
}

handleMouseMove = function (e, chartState, tradeGroups) {
    fillHoverHandler(e, chartState);
    orderHoverHandler(e, chartState);
    tradeHoverHandler(e, chartState, tradeGroups);
    const isLineHover = lineHoverHandler(e, chartState);
    const isTriggerHover = triggerHoverHandler(e, chartState);
    const isPointHover = pointHoverHandler(e, chartState);
    const hoveredTrend = trendLineHoverHandler(e, chartState)

    if (isPointHover) {
        canvas.style.cursor = 'pointer'; 
    } else if (hoveredTrend) {
	// console.log("Trend Hovered")
	window.hoveredTrendline = hoveredTrend
        canvas.style.cursor = 'pointer';
    } else if (isLineHover || isTriggerHover) {
        canvas.style.cursor = 'pointer';
    } else {
        hidePointTooltip(); 
        hideTrendlineTooltip();
        window.hoveredTrendline = null
        canvas.style.cursor = 'default';
    }
};

const pointHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    let closestPoint = null;
    let minDistance = 5;

    const allPoints = [...trendlinePoints, ...subtrendPoints];
    allPoints.forEach(point => {
        const dx = point.x - mouseX;
        const dy = point.y - mouseY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < minDistance) {
            minDistance = distance;
            closestPoint = point;
        }
    });

    if (closestPoint && minDistance < 10) {
        window.hoveredPoint = closestPoint;
        showPointTooltip(closestPoint, mouseX, mouseY);
        // Set specific hovered point variables for rendering
        if (trendlinePoints.includes(closestPoint)) {
            window.hoveredTrendlinePoint = closestPoint;
            window.hoveredSubtrendPoint = null;
        } else if (subtrendPoints.includes(closestPoint)) {
            window.hoveredSubtrendPoint = closestPoint;
            window.hoveredTrendlinePoint = null;
        }
    } else {
        window.hoveredPoint = null;
        window.hoveredTrendlinePoint = null;
        window.hoveredSubtrendPoint = null;
        hidePointTooltip();
    }
    return closestPoint !== null;
};

function trendLineHoverHandler(e, chartState) {
    const rect = canvas.getBoundingClientRect()
    const mouseX = e.clientX - rect.left
    const mouseY = e.clientY - rect.top

    let closestTrend = null
    let minDistance = Infinity

    chartState.trendlines.forEach(trendline => {
        // Main trendline coordinates
        const startX = chartState.margin + ((trendline.start.time - chartState.firstCandleTime) / (chartState.lastCandleTime - chartState.firstCandleTime)) * (chartState.width - 2 * chartState.margin);
        const endX = chartState.margin + ((trendline.end.time - chartState.firstCandleTime) / (chartState.lastCandleTime - chartState.firstCandleTime)) * (chartState.width - 2 * chartState.margin);
        const startY = chartState.height - chartState.margin - ((trendline.start.point - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) * (chartState.height - 2 * chartState.margin);
        const endY = chartState.height - chartState.margin - ((trendline.end.point - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) * (chartState.height - 2 * chartState.margin);

        const distance = distanceToLineSegment(mouseX, mouseY, startX, startY, endX, endY);
        if (distance < minDistance) {
            minDistance = distance;
            closestTrend = trendline;
        }

        // Subtrend coordinates
        // trendline.trends.forEach(subtrend => {
        //     const subStartX = chartState.margin + ((subtrend.start.time - chartState.firstCandleTime) / (chartState.lastCandleTime - chartState.firstCandleTime)) * (chartState.width - 2 * chartState.margin);
        //     const subEndX = chartState.margin + ((subtrend.end.time - chartState.firstCandleTime) / (chartState.lastCandleTime - chartState.firstCandleTime)) * (chartState.width - 2 * chartState.margin);
        //     const subStartY = chartState.height - chartState.margin - ((subtrend.start.point - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) * (chartState.height - 2 * chartState.margin);
        //     const subEndY = chartState.height - chartState.margin - ((subtrend.end.point - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) * (chartState.height - 2 * chartState.margin);
        //
        //     const subDistance = distanceToLineSegment(mouseX, mouseY, subStartX, subStartY, subEndX, subEndY);
        //     if (subDistance < minDistance) {
        //         minDistance = subDistance;
        //         closestTrend = subtrend;
        //     }
        // });
    });
    const threshold = 5
    if (minDistance < threshold) {
        showTrendlineTooltip(closestTrend, mouseX, mouseY)
        // return true
        return closestTrend
    } else {
        hideTrendlineTooltip()
        // return false
        return null
    }
}

const fillHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    current_fills.forEach(fill => {
        const fillTime = new Date(fill.time).getTime() / 1000;
        const firstCandleTime = window.stockData[start].Timestamp;
        const timeRange = window.stockData[end - 1].Timestamp - firstCandleTime;
        const xPosition = chartState.margin + ((fillTime - firstCandleTime) / timeRange) * (chartState.width - 2 * chartState.margin);
        const fillY = chartState.height - chartState.margin - ((fill.price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) * (chartState.height - 2 * chartState.margin);

        const distance = Math.sqrt(Math.pow(xPosition - mouseX, 2) + Math.pow(fillY - mouseY, 2));
        if (distance < 8) {
            chartState.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            chartState.ctx.fillRect(mouseX + 10, mouseY - 40, 120, 60);
            chartState.ctx.fillStyle = 'white';
            chartState.ctx.font = '12px Arial';
            chartState.ctx.fillText(`Fill Price: ${fill.price}`, mouseX + 15, mouseY - 20);
            chartState.ctx.fillText(`Size: ${fill.size}`, mouseX + 15, mouseY);
        }
    });
};

const orderHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    current_orders.forEach(order => {
        const orderY = chartState.height - chartState.margin -
            ((order.Price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
            (chartState.height - 2 * chartState.margin);

        if (Math.abs(mouseY - orderY) < 5) {
            // Check if a menu already exists
            let existingMenu = document.querySelector('.order-menu');

            if (!existingMenu) {
                // Remove any existing menus
                document.querySelectorAll('.order-menu').forEach(el => el.remove());

                // Create a new menu
                const menu = document.createElement('div');
                menu.className = 'order-menu';
                menu.style.position = 'absolute';
                menu.style.left = `${e.pageX - 150}px`;
                menu.style.top = `${e.pageY - 10}px`;
                menu.style.zIndex = '1000';
                menu.style.pointerEvents = 'auto';

                // Populate menu content
                menu.innerHTML = `
          <div><strong>Order Details</strong></div>
          <div>Side: ${order.Side}</div>
          <div>Product: ${order.ProductID}</div>
          <div>Price: ${order.Price}</div>
          <div>Size: ${order.Size}</div>
          <div>Status: ${order.Status}</div>
          <div class="cancel-button" onclick="cancelOrder('${order.OrderID}', ${order.XchID})">Cancel Order</div>
        `;

                // Add hover behavior to prevent premature removal
                let isMouseOverMenu = false;

                // Keep track of hover state for the menu
                menu.addEventListener('mouseenter', () => {
                    // console.log("Menu enter");
                    isMouseOverMenu = true;
                });

                // Remove menu on mouse leave
                menu.addEventListener('mouseleave', function () {
                    // console.log("Menu leave");
                    this.remove(); // Remove the menu when the mouse leaves it
                });

                // Append the menu to the body
                document.body.appendChild(menu);
            }
        }
    });
};

const tradeHoverHandler = function (e, chartState, groups) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    Object.values(groups).forEach(trades => {
        trades.forEach(trade => {
            const entryY = chartState.height - chartState.margin -
                ((trade.entry_price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
                (chartState.height - 2 * chartState.margin);
            const stopY = chartState.height - chartState.margin -
                ((trade.stop_price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
                (chartState.height - 2 * chartState.margin);
            const ptY = chartState.height - chartState.margin -
                ((trade.pt_price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
                (chartState.height - 2 * chartState.margin);

            if (isMouseNearLine(mouseY, entryY) || isMouseNearLine(mouseY, stopY) || isMouseNearLine(mouseY, ptY)) {
                let existingMenu = document.querySelector('.trade-menu');

                if (!existingMenu) {
                    document.querySelectorAll('.trade-menu').forEach(el => el.remove());

                    const menu = document.createElement('div');
                    menu.className = 'trade-menu';
                    menu.style.position = 'absolute';
                    menu.style.left = `${e.pageX - 150}px`;
                    menu.style.top = `${e.pageY - 10}px`;
                    menu.style.zIndex = '1000';
                    menu.style.pointerEvents = 'auto';

                    const groupTrades = groups[trade.group_id];
                    menu.innerHTML = `
                <div><strong>Trade Block ${trade.group_id}</strong></div>
                <div>Side: ${trade.side}</div>
                <div>Entry: ${trade.entry_price.toFixed(8)} (${trade.entry_status || 'PENDING'})</div>
                <div>Stop: ${trade.stop_price.toFixed(8)} (${trade.stop_status || 'PENDING'})</div>
                <div>Size: ${trade.size}</div>
                <div>Created: ${new Date(trade.created_at).toLocaleString()}</div>
                <div>Targets:</div>
                ${groupTrades.map(t => {
                        const rr = ((Math.abs(t.pt_price - t.entry_price)) /
                            (Math.abs(t.entry_price - t.stop_price))).toFixed(2);
                        return `<div>PT${t.pt_amount}: ${t.pt_price.toFixed(8)} (${t.pt_status || 'PENDING'})
                            <span style="color: #ffff00"> R:R ${rr}</span></div>`;
                    }).join('')}
                <div class="cancel-button" onclick="deleteTradeBlock('${trade.group_id}')">Delete Trade Block</div>
            `;

                    menu.addEventListener('mouseenter', () => {
                        // console.log("Trade Menu enter");
                        menu.dataset.hovering = 'true';
                    });

                    menu.addEventListener('mouseleave', function () {
                        // console.log("Trade Menu leave");
                        this.remove();
                    });

                    document.body.appendChild(menu);
                }
            }
        });
    });
};

const lineHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    let isNearLine = false;
    draw_lines.forEach((line, index) => {
        const lineY = chartState.height - chartState.margin -
            ((line.price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
            (chartState.height - 2 * chartState.margin);

        if (isMouseNearLine(mouseY, lineY)) {
            console.log("near::lineHoverHandler");
            let existingMenu = document.querySelector('.line-menu');

            if (!existingMenu) {
                document.querySelectorAll('.line-menu').forEach(el => el.remove());

                const menu = document.createElement('div');
                menu.className = 'line-menu';
                menu.style.position = 'absolute';
                menu.style.left = `${e.pageX - 100}px`;
                menu.style.top = `${e.pageY - 10}px`;
                menu.style.display = 'block';
                menu.style.zIndex = '1000';
                menu.style.pointerEvents = 'auto';

                menu.innerHTML = `
                    <div class="line-menu-item" data-action="entry">Trade Entry</div>
                    <div class="line-menu-item" data-action="pt">Profit Target</div>
                    <div class="line-menu-item" data-action="stop">Stop Loss</div>
                    <div class="line-menu-item" data-action="trigger">Trigger</div>
                    <div class="line-menu-item" data-action="delete">Delete</div>
                    <div class="line-menu-item create-trade-btn" data-action="create">Create Trade</div>
                `;

                menu.addEventListener('click', () => {
                    console.log("click::lineHoverHandler");
                    menu.dataset.hovering = 'true';
                });

                menu.addEventListener('mouseleave', () => {
                    console.log("mouse-leave::lineHoverHandler");
                    menu.dataset.hovering = 'false';
                    menu.remove();
                });

                menu.querySelectorAll('.line-menu-item').forEach(item => {
                    item.addEventListener('click', function (e) {
                        const action = this.dataset.action;
                        console.log("handle_line_action", draw_lines[activeLineIndex]);
                        handleLineAction(action, draw_lines[activeLineIndex]);
                        menu.remove();
                        drawCandlestickChart(window.stockData, window.start, window.end);
                    });
                });

                document.body.appendChild(menu);
            }

            isNearLine = true;
            activeLineIndex = index;
        }
    });

    if (!isNearLine) {
        activeLineIndex = -1;
        const menu = document.querySelector('.line-menu');
        if (menu && menu.dataset.hovering !== 'true') {
            menu.remove();
        }
    }
    return isNearLine;
};

window.cancelTrigger = function (triggerID) {
    fetch('/delete-trigger', {
        method: 'DELETE',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ trigger_id: triggerID })
    })
        .then(response => response.json())
        .then(data => {
            console.log('Trigger cancelled:', data)
            window.current_triggers = window.current_triggers.filter(triggers => triggers.id !== triggerID) || []
            drawCandlestickChart(window.stockData, window.start, window.end)
        })
        .catch(error => {
            console.error('Error cancelling trigger:', error);
        })
}

window.cancelOrder = function (orderId, xchId) {
    fetch('/cancel-order', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            order_id: orderId,
            xch_id: xchId
        })
    })
        .then(response => response.json())
        .then(data => {
            const index = current_orders.findIndex(o => o.OrderID === orderId);
            if (index !== -1) {
                current_orders.splice(index, 1);
            }
            drawCandlestickChart(window.stockData, start, end);
            document.querySelectorAll('.order-menu').forEach(el => el.remove());
        })
        .catch(error => console.error('Error canceling order:', error));
}


window.deleteTradeBlock = function (groupId) {
    fetch('/delete-trade-block', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            group_id: groupId
        })
    })
        .then(response => response.json())
        .then(data => {
            current_trades = current_trades.filter(t => t.group_id !== groupId)
            drawCandlestickChart(window.stockData, start, end)
            document.querySelectorAll('.trade-menu').forEach(el => el.remove())
        })
        .catch(error => console.error('Error deleting trade group:', error))
}

canvas.addEventListener('mouseup', function () {
    // console.log("MouseUp")
    if (window.currentTool) {
        drawingStart = null
        if (window.currentTool === 'box') {
            console.log(" - _Box end", mouseX, mouseY)
        }
    } else {
        isDragging = false;
        canvas.style.cursor = 'crosshair';
    }
});

canvas.addEventListener('mouseleave', function () {
    // console.log("Canvas Leave2")
    isDragging = false;
    canvas.style.cursor = 'crosshair';
});

// canvas.addEventListener('click', function (event) {
//     if (window.hoveredTrendlinePoint) {
//         const mouseX = event.pageX;
//         const mouseY = event.pageY;
//         // Find the current point object since trendlinePoints is recalculated on redraw
//         const point = trendlinePoints.find(p =>
//             p.trendline === window.hoveredTrendlinePoint.trendline &&
//             p.type === window.hoveredTrendlinePoint.type
//         );
//         if (point) {
//             showTrendlinePointMenu(point, mouseX, mouseY);
//         }
//     }
// });

canvas.addEventListener('click', function (event) {
	window.triggerClickHandler(event, chartState);
	if (window.hoveredTrendline && window.hoveredTrendline.trends && window.hoveredTrendline.trends.length > 0) {
        window.trendlinePath.push(window.hoveredTrendline)
        window.currentTrendlines = window.hoveredTrendline.trends
        window.drawCandlestickChart(window.stockData, window.start, window.end)
		// clickTrendline(event, chartState)
	} else if (!window.hoveredTrendline && window.trendlinePath.length > 0) {
        window.trendlinePath.pop()
        if (window.trendlinePath.length > 0) {
            window.currentTrendlines = window.trendlinePath[window.trendlinePath.length - 1].trends
        } else {
            window.currentTrendlines = window.trendlines
        }
        window.drawCandlestickChart(window.stockData, window.start, window.end)
    }

    if (window.hoveredPoint) {
        const mouseX = event.pageX
        const mouseY = event.pageY
        showTrendlinePointMenu(window.hoveredPoint, mouseX, mouseY)
    }
})

function clickTrendline(event, chartState) {
    console.log("Trend Click ChartState", chartState)
}

// canvas.addEventListener('click', function (event) {
//     console.log("Line Clicked", draw_lines)
//     if (activeLineIndex >= 0 && draw_lines[activeLineIndex]) {
//         showLineMenu(event.pageX, event.pageY);
//         console.log("Line clicked - Price:", draw_lines[activeLineIndex].price);
//         console.log("Line type", draw_lines[activeLineIndex].type)
//         if (draw_lines[activeLineIndex].type) {
//             console.log("Line type:", draw_lines[activeLineIndex].type);
//         }
//     }
// });
//
// canvas.addEventListener('click', function (event) {
//     console.log("click2")
//
//     if (window.currentTool && ['trigger', 'entry', 'stop', 'pt'].includes(window.currentTool)) {
//         const rect = canvas.getBoundingClientRect();
//         const mouseY = event.clientY - rect.top;
//         const chartState = drawCandlestickChart(stockData, start, end);
//         const price = calculatePrice(mouseY, chartState.height, chartState.margin, chartState.minPrice, chartState.maxPrice);
//
//         const line = { price: price };
//         handleLineAction(window.currentTool, line);
//         drawCandlestickChart(stockData, start, end);
//         window.updateSidebar();
//     }
// });

// canvas.addEventListener('click', function (event) {
//     console.log("Click3")
//     // Existing trigger menu handler
//     window.triggerClickHandler(event, chartState);
//
//     // New trade tool handler
//     if (window.currentTool && ['trigger', 'entry', 'stop', 'pt'].includes(window.currentTool)) {
//         const rect = canvas.getBoundingClientRect();
//         const mouseY = event.clientY - rect.top;
//         const chartState = drawCandlestickChart(stockData, start, end);
//         const price = calculatePrice(mouseY, chartState.height, chartState.margin, chartState.minPrice, chartState.maxPrice);
//         const line = { price: price };
//         handleLineAction(window.currentTool, line);
//         drawCandlestickChart(stockData, start, end);
//         window.updateSidebar();
//     }
// });

canvas.addEventListener('click', function (event) {
    console.log("Canvas Clicked 1")
    if (window.hoveredPoint) {
        const mouseX = event.pageX
        const mouseY = event.pageY
        showTrendlinePointMenu(window.hoveredPoint, mouseX, mouseY)
    }
    
    // showPointMenu(event.x, event.y)
})



canvas.addEventListener('mouseleave', function (event) {
    // console.log("Canvas Leave");

    // hideTrendlinePointTooltip()
    hidePointTooltip()
    // Get mouse position
    const mouseX = event.clientX;
    const mouseY = event.clientY;

    // Get canvas and menu boundaries
    const canvasRect = canvas.getBoundingClientRect();
    const menu = document.querySelector('.order-menu');
    const menuRect = menu ? menu.getBoundingClientRect() : null;

    // Check if mouse is still inside canvas or menu
    const isMouseInCanvas =
        mouseX >= canvasRect.left &&
        mouseX <= canvasRect.right &&
        mouseY >= canvasRect.top &&
        mouseY <= canvasRect.bottom;

    const isMouseInMenu =
        menuRect &&
        mouseX >= menuRect.left &&
        mouseX <= menuRect.right &&
        mouseY >= menuRect.top &&
        mouseY <= menuRect.bottom;

    if (!isMouseInCanvas && !isMouseInMenu) {
        // console.log("Mouse has left both canvas and menu");
        document.querySelectorAll('.order-menu').forEach(el => el.remove());
    }
});


document.getElementById('chartContainer').addEventListener('wheel', function (event) {
    event.preventDefault();
    if (event.deltaY < 0) { // Zoom in
        if (window.end - window.start > window.zoomFactor) {
            window.start += window.zoomFactor;
            window.end -= window.zoomFactor;
        }
    } else { // Zoom out
        window.start = Math.max(0, window.start - window.zoomFactor);
        window.end = Math.min(window.stockData.length, window.end + window.zoomFactor);
    }
    window.drawCandlestickChart(window.stockData, window.start, window.end);
});

window.addEventListener('resize', function () {
    chartState = drawCandlestickChart(window.stockData, start, end);
});

// document.getElementById('line').addEventListener('click', function () {
//     console.log("Line Selected")
//     if (window.currentTool == 'line' || window.currentTool == 'box') {
//         window.currentTool = null
//     }
//     else {

//         window.currentTool = 'line'
//     }
// })
// document.getElementById('box').addEventListener('click', function () {
//     if (window.currentTool == 'line' || window.currentTool == 'box') {
//         window.currentTool = null
//     }
//     else {
//         console.log("Box Selected")
//         window.currentTool = 'box'
//     }
// })

document.getElementById('base-trends').addEventListener('click', function () {
    console.log("base-trends")
    window.base_trends_toggle = !window.base_trends_toggle
    window.drawCandlestickChart(window.stockData, start, end)
})

document.getElementById('meta-trends').addEventListener('click', function () {
    console.log("meta-trends")
    window.meta_trends_toggle = !window.meta_trends_toggle
    window.drawCandlestickChart(window.stockData, start, end)
})

document.querySelectorAll('.line-menu-item').forEach(item => {
    item.addEventListener('click', function (e) {
        const action = this.dataset.action;
        if (activeLineIndex >= 0 && draw_lines[activeLineIndex]) {
            const line = draw_lines[activeLineIndex];

            switch (action) {
                case 'trigger':
                    const lastCandle = window.stockData[window.stockData.length - 1]
                    const currentPrice = lastCandle.Close

                    line.type = 'trigger';
                    line.color = '%ff00ff';

                    const triggerData = {
                        product_id: selectedProduct.product_id,
                        type: line.price > currentPrice ? 'price_above' : 'price_below',
                        price: parseFloat(line.price),
                        status: 'active',
                        xch_id: exchange.ID
                    }

                    fetch('create-trigger', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(triggerData)
                    })
                        .then(response => response.json())
                        .then(data => {
                            console.log('3Trigger Created: ', data)
                            line.triggerId = data.id
                        })
                        .catch(error => {
                            console.log('Error creating trigger:', error)
                        })
                    break;

                case 'entry':
                    line.type = 'entry';
                    line.color = '#00ff00';
                    console.log("Entry line at price:", line.price);
                    window.currentTrade = {
                        entry: line.price,
                        productId: selectedProduct.product_id
                    };
                    break;

                case 'pt':
                    line.type = 'pt';
                    line.color = '#ffff00';
                    console.log("Profit target at price:", line.price);
                    if (window.currentTrade && window.currentTrade.entry) {
                        window.currentTrade.target = line.price;
                    }
                    break;

                case 'stop':
                    line.type = 'stop';
                    line.color = '#ff0000';
                    console.log("Stop loss at price:", line.price);
                    if (window.currentTrade && window.currentTrade.entry) {
                        window.currentTrade.stop = line.price;
                    }
                    break;

                case 'delete':
                    draw_lines.splice(activeLineIndex, 1);
                    console.log("Line deleted at price:", line.price);
                    break;

                case 'create':
                    const entryLine = draw_lines.find(line => line.type === 'entry')
                    const stopLine = draw_lines.find(line => line.type === 'stop')
                    const targetLine = draw_lines.find(line => line.type === 'pt')

                    if (!entryLine || !stopLine || !targetLine) {
                        alert('Please set entry, stop loss, and profit target levels before creating trade')
                        return
                    }

                    const tradeSetup = {
                        entry: entryLine.price,
                        size: 500,
                        stop: stopLine.price,
                        target: targetLine.price,
                        productId: selectedProduct.product_id
                    }
                    createTradeGroup(tradeSetup)
                    console.log("Trade group created", tradeSetup)
                    break;
            }
        }

        hideLineMenu();
        drawCandlestickChart(window.stockData, start, end);
    });
});


document.addEventListener('DOMContentLoaded', function () {
    console.log("DOM Loaded");
    const trendlineButtons = document.querySelectorAll('.trendline-btn');
    console.log("Trendline Buttons", trendlineButtons);
    trendlineButtons.forEach(button => {
        button.addEventListener('click', function () {
            console.log("Trendline Dataset", this.dataset);
            const trendlineId = this.dataset.trendlineId;
            if (visibleTrendlines.has(trendlineId)) {
                visibleTrendlines.delete(trendlineId);
                this.classList.remove('btn-primary');
                this.classList.add('btn-secondary');
            } else {
                visibleTrendlines.add(trendlineId);
                this.classList.remove('btn-secondary');
                this.classList.add('btn-primary');
            }
            toggleTrendline(trendlineId);
            drawCandlestickChart(window.stockData, start, end);
        });
    });
});

document.addEventListener('DOMContentLoaded', () => {
    connectToBackend();

    // Initialize Bootstrap tabs if they exist
    const tabElements = document.querySelectorAll('[data-bs-toggle="tab"]');
    if (tabElements.length > 0) {
        tabElements.forEach(el => {
            new bootstrap.Tab(el);
        });
    }
});

document.addEventListener('click', function (e) {
    if (!e.target.closest('lineMenu') && !e.target.closest('#candlestickChart')) {
        window.hideLineMenu();
    }
});

// document.getElementById('trigger').addEventListener('click', function () {
//     if (window.currentTool === 'trigger') {
//         console.log("TRIGGER_DESELECTED")
//         window.currentTool = null;
//     } else {
//         window.currentTool = 'trigger';
//         console.log("TRIGGER_SELECTED")
//     }
// });

window.showLineMenu = function (x, y) {
    const menu = document.getElementById('lineMenu');
    const line = draw_lines[activeLineIndex];

    // Calculate line's Y position using stored chartState
    if (chartState) {
        const lineY = chartState.height - chartState.margin -
            ((line.price - chartState.minPrice) /
                (chartState.maxPrice - chartState.minPrice)) *
            (chartState.height - 2 * chartState.margin);

        menu.style.display = 'block';
        menu.style.left = `${x}px`;
        menu.style.top = `${lineY}px`;
    }
}

window.hideLineMenu = function () {
    const menu = document.getElementById('lineMenu');
    menu.style.display = 'none';
}

// trendlines.js

console.log("trendlines.js")

window.pointTooltip = document.createElement('div');
window.pointTooltip.className = 'point-tooltip';
window.pointTooltip.style.position = 'absolute';
window.pointTooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
window.pointTooltip.style.color = 'white';
window.pointTooltip.style.padding = '5px';
window.pointTooltip.style.borderRadius = '3px';
window.pointTooltip.style.display = 'none';
document.body.appendChild(window.pointTooltip);

window.trendLineTooltip = document.createElement('div');
window.trendLineTooltip.className = 'trend-line-tooltip';
window.trendLineTooltip.style.position = 'absolute';
window.trendLineTooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
window.trendLineTooltip.style.color = 'white';
window.trendLineTooltip.style.padding = '5px';
window.trendLineTooltip.style.borderRadius = '3px';
window.trendLineTooltip.style.display = 'none';
document.body.appendChild(window.trendLineTooltip);


function getTrendStartFinish(trend, trendends = []) {
    if (trend.trends.length() > 0) {
    }

    return trendends

}

function showTrendlineTooltip(trend, mouseX, mouseY) {

    // let html = `
    //     <div>TrendDetails</div>
    //     <div>Start: ${trend.start.point.toFixed(8)} at ${new Date(trend.start.time * 1000).toLocaleString()}</div>
    //     <div>End: ${trend.end.point.toFixed(8)} at ${new Date(trend.end.time * 1000).toLocaleString()}</div>
    //     <div>Status: ${trend.status || 'N/A'}</div>
    // `

    // if (trend.trends && trend.trends.length > 0) {
    //     html += `<div>Subtrends: ${trend.trends.length}</div><ul>`
    //     trend.trends.forEach(subtrend => {
    //         html += `<li>${subtrend.start.point.toFixed(8)} to ${subtrend.end.point.toFixed(8)}</li>`
    //     })
    //     html += '</ul>'
    // }

    // if (trend.trends.length > 1) {
    //     html += `
    //         <div>Trend_Start: ${trend.trends[0].end.trendStart}</div>
    //         <div>Trend_Finish: ${trend.trends[trend.trends.length -1].start.trendStart}</div>
    //     `
    // }

    // console.log("|M2_X|",trend.start.trendStart, trend.end.trendStart, trend.trends.length, trend.trends)


    // window.trendstartlines.push(trend.trends[0])
    // window.trendstartlines.push(trend.trends[trend.trends.length - 2])

    // console.log("trendstartlines", window.trendstartlines)

    // window.trendLineTooltip.innerHTML = html
    // window.trendLineTooltip.style.left = `${mouseX + 10}px`
    // window.trendLineTooltip.style.top = `${mouseY + 10}px`
    // window.trendLineTooltip.style.display = 'block'
}

function hideTrendlineTooltip() {
    // console.log("Hide Trend Start/Stop")
    window.trendLineTooltip.style.display = 'none'
    window.trendstartlines = []
}

window.showPointTooltip = function (point, mouseX, mouseY) {
    const trend = point.trend; // Use point.trend instead of point.trendline
    const time = point.type === 'start' ? trend.start.time : trend.end.time;
    const price = point.price; // Use the stored price directly

    // Safely determine subtrends count, default to 0 if trend.trends is undefined
    const subTrendsCount = trend.trends ? trend.trends.length : 0;

    window.pointTooltip.innerHTML = `
        <div>Trendline Index: ${point.index + 1}</div>
        <div>Point: ${point.type}</div>
        <div>Time: ${new Date(time * 1000).toLocaleString()}</div>
        <div>Price: ${price.toFixed(8)}</div>
        <div>SubTrends: ${subTrendsCount}</div>
    `;
    window.pointTooltip.style.left = `${mouseX + 10}px`;
    window.pointTooltip.style.top = `${mouseY + 10}px`;
    window.pointTooltip.style.display = 'block';
};

window.hidePointTooltip = function () {
    if (window.pointTooltip) {
        window.pointTooltip.style.display = 'none';
    }
}

window.toggleTrendline = function (key) {
    console.log("Toggle Trendline", key);
    console.log("Visible Trendlines", visibleTrendlines)
}

window.showTrendlinePointMenu = function (point, mouseX, mouseY) {
    // Remove any existing menu
    document.querySelectorAll('.trendline-point-menu').forEach(el => el.remove());

    const menu = document.createElement('div');
    menu.className = 'trendline-point-menu';
    menu.style.position = 'absolute';
    menu.style.left = `${mouseX - 100}px`;
    menu.style.top = `${mouseY - 10}px`;
    menu.style.backgroundColor = '#333';
    menu.style.color = 'white';
    menu.style.padding = '10px';
    menu.style.border = '1px solid #666';
    menu.style.borderRadius = '4px';
    menu.style.display = 'block';
    menu.style.zIndex = '1000';
    menu.style.pointerEvents = 'auto';
    menu.style.minWidth = '150px';

    // Use the point's stored price
    const price = point.price;

    menu.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <strong>Trend Point Menu</strong>
            <span class="close-menu" style="cursor: pointer; padding: 0 5px;">×</span>
        </div>
        <div>Price: ${price.toFixed(8)}</div>
        <div class="line-menu-item" data-action="entry">Set as Entry</div>
        <div class="line-menu-item" data-action="stop">Set as Stop Loss</div>
        <div class="line-menu-item" data-action="pt">Set as Profit Target</div>
        <div class="line-menu-item" data-action="trigger">Set as Trigger</div>
    `;

    document.body.appendChild(menu);

    // Add event listeners to menu items
    menu.querySelectorAll('.line-menu-item').forEach(item => {
        item.addEventListener('click', function () {
            const action = this.dataset.action;
            const line = { price: price }; // Create a line object with the correct price
            handleLineAction(action, line);
            menu.remove();
            drawCandlestickChart(window.stockData, window.start, window.end);
        });
    });

    menu.querySelector('.close-menu').addEventListener('click', () => {
        menu.remove();
    });

    // Close menu when hovering off
    menu.addEventListener('mouseleave', () => {
        menu.remove();
    });

    // Close menu when clicking outside
    const closeMenuOnOutsideClick = (event) => {
        if (!menu.contains(event.target) && !event.target.classList.contains('line-menu-item')) {
            menu.remove();
            document.removeEventListener('click', closeMenuOnOutsideClick);
        }
    };
    setTimeout(() => {
        document.addEventListener('click', closeMenuOnOutsideClick);
    }, 0);
};
