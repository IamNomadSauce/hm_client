{{define "chart"}}
<div id="chartContainer" style="width: 100%; height: calc(100vh - 400px);">
  <div id="toolbar">
    <button id="line" class="btn btn-sm btn-secondary">Line</button>
    <button id="box" class="btn btn-sm btn-secondary">Box</button>
  </div>
  <canvas id="candlestickChart"></canvas>
  <div id="lineMenu" class="line-menu" style="display: none;">
    <div class="line-menu-item" data-action="entry">Trade Entry</div>
    <div class="line-menu-item" data-action="pt">Profit Target</div>
    <div class="line-menu-item" data-action="stop">Stop Loss</div>
    <div class="line-menu-item" data-action="alert">Alert</div>
    <div class="line-menu-item" data-action="delete">Delete</div>
  </div>

</div>

<style>
  #chartContainer {
    position: relative;
    width: 100vw;
    margin-left: calc(-50vw + 50%);
  }

  #candlestickChart {
    width: 100% !important;
    height: 100% !important;
    cursor: grab;
  }

  .line-menu {
    position: absolute;
    background: #212529;
    border: 1px solid #444;
    border-radius: 4px;
    padding: 5px 0;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  }

  .line-menu-item {
    padding: 8px 15px;
    color: white;
    cursor: pointer;
    font-size: 14px;
    white-space: nowrap;
  }

  .line-menu-item:hover {
    background: #2c3034;
  }
</style>

<script>
  var stockData = {{.Candles }};
  var selectedProduct = {{.SelectedProduct }};
  var exchange = {{.SelectedExchange }};
  var all_fills = exchange.Fills;
  var all_orders = exchange.Orders;
  var current_fills = all_fills.filter(product => product.productid === selectedProduct.product_id)
  var current_orders = all_orders.filter(product => product.ProductID === selectedProduct.product_id)
  var mouseX = 0;
  var mouseY = 0;
  var currentTool = null
  var drawingStart = null
  var draw_boxes = []
  var draw_lines = []
  var activeLineIndex = -1;



  console.log("Current Exchange", exchange)
  console.log("Selected Product", selectedProduct)
  console.log("Fills", all_fills)
  console.log("Orders", all_orders)
  console.log("Current Fills", current_fills)
  console.log("Current Orders", current_orders)



  function drawToolbar(ctx, width, height, margin, minPrice, maxPrice) {
    let activeLineIndex = -1;
    draw_lines.forEach((line, index) => {
      // Convert price back to Y coordinate
      const y = height - margin - ((line.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

      ctx.beginPath();
      ctx.moveTo(margin, y);
      ctx.lineTo(width - margin, y);
      ctx.strokeStyle = line.color || 'yellow';
      ctx.stroke();

      // Draw price label with type if exists
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.fillText(`${line.type ? line.type + ' - ' : ''}${line.price.toFixed(2)}`, width - 120, y - 5);
    });


    if (currentTool === 'line' && drawingStart) {
      ctx.beginPath();
      ctx.moveTo(margin, drawingStart.y);
      ctx.lineTo(width - margin, drawingStart.y);
      ctx.strokeStyle = 'yellow';
      ctx.stroke();
    } else if (currentTool === 'box' && drawingStart) {
      ctx.beginPath();
      ctx.rect(drawingStart.x, drawingStart.y, mouseX - drawingStart.x, mouseY - drawingStart.y);
      ctx.strokeStyle = 'yellow';
      ctx.stroke();
    }
  }


  function drawCandlestickChart(data, start, end) {
    var canvas = document.getElementById('candlestickChart');
    var ctx = canvas.getContext('2d');

    // Set canvas size to match container
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;

    // Clear the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Define chart dimensions and margins
    var width = canvas.width;
    var height = canvas.height;
    var margin = 50;
    var visibleData = data.slice(start, end);
    var candleWidth = (width - 2 * margin) / visibleData.length;

    // Find the min and max values for scaling
    var minPrice = Math.min(...visibleData.map(d => d.Low));
    var maxPrice = Math.max(...visibleData.map(d => d.High));

    let exchange = "{{.SelectedExchange.Name}}"
    let orders = "{{.SelectedExchange.Orders}}"
    // console.log("Product", "{{.SelectedProduct}}")
    // console.log("Orders", "{{.SelectedExchange.Orders}}")

    let isNearLine = false;
    draw_lines.forEach((line, index) => {
      const lineY = height - margin - ((line.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
      if (isMouseNearLine(mouseY, lineY)) {
        // console.log("Mouse Hover", line, mouseY)
        canvas.style.cursor = 'pointer';
        isNearLine = true;
        activeLineIndex = index;
      }
    });

    if (!isNearLine) {
      canvas.style.cursor = 'default';
      activeLineIndex = -1;
    }

    // Draw each candlestick
    visibleData.forEach((d, i) => {
      var x = margin + i * candleWidth;
      var openY = height - margin - ((d.Open - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
      var closeY = height - margin - ((d.Close - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
      var highY = height - margin - ((d.High - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
      var lowY = height - margin - ((d.Low - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

      // Draw the high-low line
      ctx.beginPath();
      ctx.moveTo(x + candleWidth / 2, highY);
      ctx.lineTo(x + candleWidth / 2, lowY);
      ctx.strokeStyle = 'gray';
      ctx.stroke();

      // Draw the open-close rectangle
      ctx.beginPath();
      ctx.rect(x, Math.min(openY, closeY), candleWidth, Math.abs(openY - closeY));
      ctx.fillStyle = d.Close >= d.Open ? 'gray' : 'gray';
      ctx.strokeStyle = 'black'
      ctx.fill();
      ctx.stroke();
    });

    // Draw Current Fills
    current_fills.forEach(fill => {
      // Use fill.time instead of fill.timestamp
      const fillTime = new Date(fill.time).getTime() / 1000; // Convert to seconds
      const firstCandleTime = visibleData[0].Timestamp; // Already in seconds
      const timeRange = visibleData[visibleData.length - 1].Timestamp - firstCandleTime;

      // Calculate x position based on time
      const xPosition = margin + ((fillTime - firstCandleTime) / timeRange) * (width - 2 * margin);

      // Calculate y position based on price
      const fillY = height - margin - ((fill.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

      // Draw dot for fill
      ctx.beginPath();
      ctx.arc(xPosition, fillY, 4, 0, 2 * Math.PI);
      ctx.fillStyle = fill.side.toLowerCase() === 'buy' ? 'lime' : 'red';
      ctx.fill();

      // Add hover detection for fills
      canvas.addEventListener('mousemove', function (e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Check if mouse is near the fill dot
        const distance = Math.sqrt(Math.pow(xPosition - mouseX, 2) + Math.pow(fillY - mouseY, 2));
        if (distance < 8) {
          // Draw tooltip
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(mouseX + 10, mouseY - 40, 120, 60);
          ctx.fillStyle = 'white';
          ctx.font = '12px Arial';
          ctx.fillText(`Fill Price: ${fill.price}`, mouseX + 15, mouseY - 20);
          ctx.fillText(`Size: ${fill.size}`, mouseX + 15, mouseY);
        }
      });
    });


    // Draw Current Orders
    current_orders.forEach(order => {
      // console.log("\n-------------------------------\n");
      // console.log("ORDER", order.ProductID, order.Side )
      // console.log("\n-------------------------------\n");
      // Convert order price to Y coordinate
      const orderY = height - margin - ((order.Price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

      // Draw the order line
      ctx.beginPath();
      ctx.moveTo(margin, orderY);
      ctx.lineTo(width - margin, orderY);
      ctx.strokeStyle = order.Side.toLowerCase() === 'BUY' ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
      ctx.stroke();

      // Draw order details
      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      ctx.fillText(`${order.Side} ${order.Size} @ ${order.Price}`, width - 150, orderY - 5);
    });

    drawToolbar(ctx, width, height, margin, minPrice, maxPrice);
    drawCrosshair(ctx, width, height, margin, minPrice, maxPrice);

    // Return chart state
    chartState = { ctx, width, height, margin, minPrice, maxPrice };
    return chartState;
  }

  // Move these functions outside drawToolbar and fix typos
  function isMouseNearLine(mouseY, lineY, threshold = 5) {
    return Math.abs(mouseY - lineY) < threshold;
  }

  var chartState = null;

  function showLineMenu(x, y) {
    const menu = document.getElementById('lineMenu');
    const line = draw_lines[activeLineIndex];

    // Calculate line's Y position using stored chartState
    if (chartState) {
      const lineY = chartState.height - chartState.margin -
        ((line.price - chartState.minPrice) /
          (chartState.maxPrice - chartState.minPrice)) *
        (chartState.height - 2 * chartState.margin);

      menu.style.display = 'block';
      menu.style.left = `${x}px`;
      menu.style.top = `${lineY}px`;
    }
  }

  function hideLineMenu() {
    const menu = document.getElementById('lineMenu');
    menu.style.display = 'none';
  }

  // Fix calculatePrice function
  function calculatePrice(y, height, margin, minPrice, maxPrice) {
    return maxPrice - ((y - margin) / (height - 2 * margin)) * (maxPrice - minPrice);
  }
  function drawCrosshair(ctx, width, height, margin, minPrice, maxPrice) {
    // Draw vertical line
    ctx.beginPath();
    ctx.moveTo(mouseX, margin);
    ctx.lineTo(mouseX, height - margin);
    ctx.strokeStyle = 'rgba(100,100,100,0.5)';
    ctx.stroke();

    // Draw horizontal line
    ctx.beginPath();
    ctx.moveTo(margin, mouseY);
    ctx.lineTo(width - margin, mouseY);
    ctx.strokeStyle = 'rgba(100,100,100,0.5)';
    ctx.stroke();

    // Calculate price - fixed formula to match the candlestick scaling
    var price = minPrice + ((height - margin - mouseY) / (height - 2 * margin)) * (maxPrice - minPrice);
    ctx.fillStyle = 'white';
    ctx.fillText(price.toFixed(2), width - 40, mouseY - 5);
  }


  // Initial parameters for zoom and pan
  var end = stockData.length
  var start = Math.max(0, end - 250); // Display first 30 data points
  var zoomFactor = 10;

  // Initial draw
  drawCandlestickChart(stockData, start, end);

  // Add event listeners for zooming and panning
  document.getElementById('chartContainer').addEventListener('wheel', function (event) {
    event.preventDefault();
    if (event.deltaY < 0) { // Zoom in
      if (end - start > zoomFactor) {
        start += zoomFactor;
        end -= zoomFactor;
      }
    } else { // Zoom out
      start = Math.max(0, start - zoomFactor);
      end = Math.min(stockData.length, end + zoomFactor);
    }
    drawCandlestickChart(stockData, start, end);
  });

  var isDragging = false;
  var startX;

  var canvas = document.getElementById('candlestickChart');

  // Update mousedown event to store price instead of coordinates
  canvas.addEventListener('mousedown', function (event) {
    var rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;

    if (currentTool) {
      if (currentTool === 'line') {
        const chartState = drawCandlestickChart(stockData, start, end);
        const price = calculatePrice(mouseY, chartState.height, chartState.margin, chartState.minPrice, chartState.maxPrice);
        draw_lines.push({
          price: price
        });
        console.log("Draw_Lines", draw_lines);
        drawCandlestickChart(stockData, start, end);
      }
      drawingStart = { x: mouseX, y: mouseY };
    } else {
      isDragging = true;
      startX = event.clientX;
      canvas.style.cursor = 'grabbing';
    }
  });

  // Fix the calculatePrice function
  function calculatePrice(y, height, margin, minPrice, maxPrice) {
    return maxPrice - ((y - margin) / (height - 2 * margin)) * (maxPrice - minPrice);
  }

  canvas.addEventListener('mouseup', function () {
    console.log("MouseUp")
    if (currentTool) {
      drawingStart = null
      if (currentTool === 'box') {
        console.log(" - _Box end", mouseX, mouseY)
      }
    } else {
      isDragging = false;
      canvas.style.cursor = 'crosshair';
    }
  });

  canvas.addEventListener('mouseleave', function () {
    isDragging = false;
    canvas.style.cursor = 'crosshair';
  });

  canvas.addEventListener('click', function (event) {
    if (activeLineIndex >= 0) {
      showLineMenu(event.pageX, event.pageY);
      console.log("Line clicked - Price:", draw_lines[activeLineIndex].price);
      if (draw_lines[activeLineIndex].type) {
        console.log("Line type:", draw_lines[activeLineIndex].type);
      }
    }
  });



  canvas.addEventListener('mousemove', function (event) {
    var rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;


    if (isDragging) {
      var dx = event.clientX - startX;
      var panFactor = Math.floor(dx / 10);
      if (panFactor !== 0) {
        start = Math.max(0, start - panFactor);
        end = Math.min(stockData.length, end - panFactor);
        startX = event.clientX;
        drawCandlestickChart(stockData, start, end);
      }
    } else {
      drawCandlestickChart(stockData, start, end);
    }
  });

  // Redraw on window resize
  window.addEventListener('resize', function () {
    chartState = drawCandlestickChart(stockData, start, end);
  });

  document.getElementById('line').addEventListener('click', function () {
    console.log("Line Selected")
    if (currentTool == 'line' || currentTool == 'box') {
      currentTool = null
    }
    else {

      currentTool = 'line'
    }
  })
  document.getElementById('box').addEventListener('click', function () {
    if (currentTool == 'line' || currentTool == 'box') {
      currentTool = null
    }
    else {
      console.log("Box Selected")
      currentTool = 'box'
    }
  })

  // Add this after your existing event listeners
  document.querySelectorAll('.line-menu-item').forEach(item => {
    item.addEventListener('click', function (e) {
      const action = this.dataset.action;
      const line = draw_lines[activeLineIndex];

      switch (action) {
        case 'entry':
          line.type = 'entry';
          line.color = '#00ff00';
          console.log("Entry line at price:", line.price);
          break;
        case 'fill':
          line.type = 'pt';
          line.color = '#ffff00';
          console.log("Fill line at price:", line.price);
          break;
        case 'stop':
          line.type = 'stop';
          line.color = '#ff0000';
          console.log("Stop loss at price:", line.price);
          break;
        case 'alert':
          line.type = 'alert';
          line.color = '#0088ff';
          console.log("Alert at price:", line.price);
          break;
        case 'delete':
          draw_lines.splice(activeLineIndex, 1);
          console.log("Line deleted at price:", line.price);
          break;
      }

      hideLineMenu();
      drawCandlestickChart(stockData, start, end);
    });
  });


  // Add click outside handler
  document.addEventListener('click', function (e) {
    if (!e.target.closest('#lineMenu') && !e.target.closest('#candlestickChart')) {
      hideLineMenu();
    }
  });

  drawCandlestickChart(stockData, start, end);

</script>
{{end}}