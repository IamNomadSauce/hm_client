{{define "chart"}}

<div id="chartContainer" style="width: 100%; height: calc(100vh - 400px);">
  <div id="toolbar">
    <button id="line" class="btn btn-sm btn-secondary">Line</button>
    <button id="box" class="btn btn-sm btn-secondary">Box</button>
  </div>
  <canvas id="candlestickChart"></canvas>
  <div id="lineMenu" class="line-menu" style="display: none;">
    <div class="line-menu-item" data-action="entry">Trade Entry</div>
    <div class="line-menu-item" data-action="pt">Profit Target</div>
    <div class="line-menu-item" data-action="stop">Stop Loss</div>
    <div class="line-menu-item" data-action="trigger">Trigger</div>
    <div class="line-menu-item" data-action="delete">Delete</div>
    <div class="line-menu-item create-trade-btn" data-action="create">Create Trade</div>
  </div>

  <div id="triggerMenu" , class="trigger-menu" style="display: none;">
    <div class="trigger-menu-item" data-action="entry">Delete</div>
    <div class="trigger-menu-item" data-action="entry">Trade Entry</div>
    <div class="trigger-menu-item" data-action="entry">Trade Entry</div>
    <div class="trigger-menu-item" data-action="entry">Trade Entry</div>
    <div class="trigger-menu-item" data-action="entry">Trade Entry</div>

  </div>

</div>

<style>
  #chartContainer {
    position: relative;
    width: 100vw;
    margin-left: calc(-50vw + 50%);
  }

  #candlestickChart {
    width: 100% !important;
    height: 100% !important;
    cursor: grab;
  }

  .line-menu {
    position: absolute;
    background: #212529;
    border: 1px solid #444;
    border-radius: 4px;
    padding: 5px 0;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  }

  .line-menu-item {
    padding: 8px 15px;
    color: white;
    cursor: pointer;
    font-size: 14px;
    white-space: nowrap;
  }

  .line-menu-item:hover {
    background: #2c3034;
  }

  .create-trade-btn {
    background-color: #198754;
    color: white;
    font-weight: bold;
    border-top: 1px solid #444;
    margin-top: 5px;
  }

  .create-trade-btn:hover {
    background-color: #157347;
  }

  .trade-menu {
    position: absolute;
    background: rgba(33, 37, 41, 0.95);
    border: 1px solid #444;
    border-radius: 4px;
    padding: 10px;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    color: white;
    font-size: 12px;
    pointer-events: none;
    max-width: 250px;
  }

  .order-menu {
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 10px;
    border-radius: 4px;
    pointer-events: auto;
  }

  .trigger-menu {
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 10px;
    border-radius: 4px;
    pointer-events: auto;
    font-size: 12px;
  }

  .cancel-button {
    margin-top: 5px;
    padding: 5px;
    background: #ff4444;
    text-align: center;
    cursor: pointer;
    border-radius: 3px;
  }

  .cancel-button:hover {
    background: #ff6666;
  }
</style>

<script>
  var stockData = {{.Candles }};
  var selectedProduct = {{.SelectedProduct }};
  var exchange = {{.SelectedExchange }};
  var selectedTimeframe = {{.SelectedTimeframe }}
  var all_fills = exchange.Fills;
  var all_orders = exchange.Orders;
  var all_trades = exchange.Trades;
  var all_triggers = exchange.Triggers || [];
  let tradeGroups = {};

  var end = stockData.length
  var start = Math.max(0, end - 250);
  var zoomFactor = 10;


  const canvas = document.getElementById('candlestickChart');
  const ctx = canvas.getContext('2d');

  var chartState = null;

  function updateChartState(ctx, width, height, margin, minPrice, maxPrice) {
    chartState = {
      ctx,
      width,
      height,
      margin,
      minPrice,
      maxPrice
    }
  }

  var mouseX = 0;
  var mouseY = 0;
  var currentTool = null
  var drawingStart = null
  var draw_boxes = []
  var draw_lines = []
  var activeLineIndex = -1;

  console.log("Triggers", all_triggers)

  var current_fills = all_fills.filter(product => product.product_id === selectedProduct.product_id)
  var current_orders = all_orders.filter(product => product.ProductID === selectedProduct.product_id)
  var current_trades = all_trades.filter(trade => trade.product_id === selectedProduct.product_id)
  var current_triggers = all_triggers.filter(trigger => trigger.product_id === selectedProduct.product_id)

  const fillHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    current_fills.forEach(fill => {
      const fillTime = new Date(fill.time).getTime() / 1000;
      const firstCandleTime = stockData[start].Timestamp;
      const timeRange = stockData[end - 1].Timestamp - firstCandleTime;
      const xPosition = chartState.margin + ((fillTime - firstCandleTime) / timeRange) * (chartState.width - 2 * chartState.margin);
      const fillY = chartState.height - chartState.margin - ((fill.price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) * (chartState.height - 2 * chartState.margin);

      const distance = Math.sqrt(Math.pow(xPosition - mouseX, 2) + Math.pow(fillY - mouseY, 2));
      if (distance < 8) {
        chartState.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        chartState.ctx.fillRect(mouseX + 10, mouseY - 40, 120, 60);
        chartState.ctx.fillStyle = 'white';
        chartState.ctx.font = '12px Arial';
        chartState.ctx.fillText(`Fill Price: ${fill.price}`, mouseX + 15, mouseY - 20);
        chartState.ctx.fillText(`Size: ${fill.size}`, mouseX + 15, mouseY);
      }
    });
  };

  const orderHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    current_orders.forEach(order => {
      const orderY = chartState.height - chartState.margin -
        ((order.Price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
        (chartState.height - 2 * chartState.margin);

      if (Math.abs(mouseY - orderY) < 5) {
        // Check if a menu already exists
        let existingMenu = document.querySelector('.order-menu');

        if (!existingMenu) {
          // Remove any existing menus
          document.querySelectorAll('.order-menu').forEach(el => el.remove());

          // Create a new menu
          const menu = document.createElement('div');
          menu.className = 'order-menu';
          menu.style.position = 'absolute';
          menu.style.left = `${e.pageX - 150}px`;
          menu.style.top = `${e.pageY - 10}px`;
          menu.style.zIndex = '1000';
          menu.style.pointerEvents = 'auto';

          // Populate menu content
          menu.innerHTML = `
          <div><strong>Order Details</strong></div>
          <div>Side: ${order.Side}</div>
          <div>Product: ${order.ProductID}</div>
          <div>Price: ${order.Price}</div>
          <div>Size: ${order.Size}</div>
          <div>Status: ${order.Status}</div>
          <div class="cancel-button" onclick="cancelOrder('${order.OrderID}')">Cancel Order</div>
        `;

          // Add hover behavior to prevent premature removal
          let isMouseOverMenu = false;

          // Keep track of hover state for the menu
          menu.addEventListener('mouseenter', () => {
            // console.log("Menu enter");
            isMouseOverMenu = true;
          });

          // Remove menu on mouse leave
          menu.addEventListener('mouseleave', function () {
            // console.log("Menu leave");
            this.remove(); // Remove the menu when the mouse leaves it
          });

          // Append the menu to the body
          document.body.appendChild(menu);
        }
      }
    });
  };

  const tradeHoverHandler = function (e, chartState, groups) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    Object.values(groups).forEach(trades => {
      trades.forEach(trade => {
        const entryY = chartState.height - chartState.margin -
          ((trade.entry_price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
          (chartState.height - 2 * chartState.margin);
        const stopY = chartState.height - chartState.margin -
          ((trade.stop_price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
          (chartState.height - 2 * chartState.margin);
        const ptY = chartState.height - chartState.margin -
          ((trade.pt_price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
          (chartState.height - 2 * chartState.margin);

        if (isMouseNearLine(mouseY, entryY) || isMouseNearLine(mouseY, stopY) || isMouseNearLine(mouseY, ptY)) {
          let existingMenu = document.querySelector('.trade-menu');

          if (!existingMenu) {
            document.querySelectorAll('.trade-menu').forEach(el => el.remove());

            const menu = document.createElement('div');
            menu.className = 'trade-menu';
            menu.style.position = 'absolute';
            menu.style.left = `${e.pageX - 150}px`;
            menu.style.top = `${e.pageY - 10}px`;
            menu.style.zIndex = '1000';
            menu.style.pointerEvents = 'auto';

            const groupTrades = groups[trade.group_id];
            menu.innerHTML = `
                        <div><strong>Trade Group ${trade.group_id}</strong></div>
                        <div>Side: ${trade.side}</div>
                        <div>Entry: ${trade.entry_price.toFixed(8)} (${trade.entry_status || 'PENDING'})</div>
                        <div>Stop: ${trade.stop_price.toFixed(8)} (${trade.stop_status || 'PENDING'})</div>
                        <div>Size: ${trade.size}</div>
                        <div>Created: ${new Date(trade.created_at).toLocaleString()}</div>
                        <div>Targets:</div>
                        ${groupTrades.map(t => {
              const rr = ((Math.abs(t.pt_price - t.entry_price)) /
                (Math.abs(t.entry_price - t.stop_price))).toFixed(2);
              return `<div>PT${t.pt_amount}: ${t.pt_price.toFixed(8)} (${t.pt_status || 'PENDING'})
                                    <span style="color: #ffff00"> R:R ${rr}</span></div>`;
            }).join('')}
                    `;

            menu.addEventListener('mouseenter', () => {
              // console.log("Trade Menu enter");
              menu.dataset.hovering = 'true';
            });

            menu.addEventListener('mouseleave', function () {
              // console.log("Trade Menu leave");
              this.remove();
            });

            document.body.appendChild(menu);
          }
        }
      });
    });
  };

  const lineHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    let isNearLine = false;
    draw_lines.forEach((line, index) => {
      const lineY = chartState.height - chartState.margin -
        ((line.price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
        (chartState.height - 2 * chartState.margin);

      if (isMouseNearLine(mouseY, lineY)) {
        let existingMenu = document.querySelector('.line-menu');

        if (!existingMenu) {
          document.querySelectorAll('.line-menu').forEach(el => el.remove());

          const menu = document.createElement('div');
          menu.className = 'line-menu';
          menu.style.position = 'absolute';
          menu.style.left = `${e.pageX - 100}px`;
          menu.style.top = `${e.pageY - 10}px`;
          menu.style.display = 'block';
          menu.style.zIndex = '1000';
          menu.style.pointerEvents = 'auto';

          menu.innerHTML = `
                    <div class="line-menu-item" data-action="entry">Trade Entry</div>
                    <div class="line-menu-item" data-action="pt">Profit Target</div>
                    <div class="line-menu-item" data-action="stop">Stop Loss</div>
                    <div class="line-menu-item" data-action="trigger">Trigger</div>
                    <div class="line-menu-item" data-action="delete">Delete</div>
                    <div class="line-menu-item create-trade-btn" data-action="create">Create Trade</div>
                `;

          menu.addEventListener('mouseenter', () => {
            menu.dataset.hovering = 'true';
          });

          menu.addEventListener('mouseleave', () => {
            menu.dataset.hovering = 'false';
            menu.remove();
          });

          // Add click handlers to menu items
          menu.querySelectorAll('.line-menu-item').forEach(item => {
            item.addEventListener('click', function (e) {
              const action = this.dataset.action;
              handleLineAction(action, draw_lines[activeLineIndex]);
              menu.remove();
              drawCandlestickChart(stockData, start, end);
            });
          });

          document.body.appendChild(menu);
        }

        canvas.style.cursor = 'pointer';
        isNearLine = true;
        activeLineIndex = index;
      }
    });

    if (!isNearLine) {
      canvas.style.cursor = 'default';
      activeLineIndex = -1;
      const menu = document.querySelector('.line-menu');
      if (menu && menu.dataset.hovering !== 'true') {
        menu.remove();
      }
    }
  };

  function handleLineAction(action, line) {
    switch (action) {
      case 'trigger':
        const lastCandle = stockData[stockData.length - 1];
        const currentPrice = lastCandle.Close;

        line.type = 'trigger';
        line.color = '#ff00ff';

        const triggerData = {
          product_id: selectedProduct.product_id,
          type: line.price > currentPrice ? 'price_above' : 'price_below',
          price: parseFloat(line.price),
          status: 'active',
          xch_id: exchange.ID
        };

        fetch('create-trigger', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(triggerData)
        })
          .then(response => response.json())
          .then(data => {
            console.log('Trigger Created: ', data);
            line.triggerId = data.id;
          })
          .catch(error => {
            console.log('Error creating trigger:', error);
          });
        break;

      case 'entry':
        line.type = 'entry';
        line.color = '#00ff00';
        window.currentTrade = {
          entry: line.price,
          productId: selectedProduct.product_id
        };
        break;

      case 'pt':
        line.type = 'pt';
        line.color = '#ffff00';
        if (window.currentTrade && window.currentTrade.entry) {
          window.currentTrade.target = line.price;
        }
        break;

      case 'stop':
        line.type = 'stop';
        line.color = '#ff0000';
        if (window.currentTrade && window.currentTrade.entry) {
          window.currentTrade.stop = line.price;
        }
        break;

      case 'delete':
        draw_lines.splice(activeLineIndex, 1);
        break;

      case 'create':
        const entryLine = draw_lines.find(l => l.type === 'entry');
        const stopLine = draw_lines.find(l => l.type === 'stop');
        const targetLine = draw_lines.find(l => l.type === 'pt');

        if (!entryLine || !stopLine || !targetLine) {
          alert('Please set entry, stop loss, and profit target levels before creating trade');
          return;
        }

        const tradeSetup = {
          entry: entryLine.price,
          size: 500,
          stop: stopLine.price,
          target: targetLine.price,
          productId: selectedProduct.product_id
        };
        createTradeGroup(tradeSetup);
        break;
    }
  }

  function hideLineMenu() {
    const menu = document.querySelector('.line-menu');
    if (menu) {
      menu.style.display = 'none';
    }
  }

  function displayTradeMenu(x, y, trade, trades) {
    // Remove any existing menus first
    document.querySelectorAll('.trade-menu').forEach(el => el.remove());

    const menu = document.createElement('div');
    menu.className = 'trade-menu';
    menu.style.left = `${x + 10}px`;
    menu.style.top = `${y + 10}px`;

    menu.innerHTML = `
        <div><strong>Trade Group ${trade.group_id}</strong></div>
        <div>Side: ${trade.side}</div>
        <div>Entry: ${trade.entry_price.toFixed(8)} (${trade.entry_status || 'PENDING'})</div>
        <div>Stop: ${trade.stop_price.toFixed(8)} (${trade.stop_status || 'PENDING'})</div>
        <div>Size: ${trade.size}</div>
        <div>Created: ${new Date(trade.created_at).toLocaleString()}</div>
        <div>Targets:</div>
        ${trades.map(t => {
      const rr = ((Math.abs(t.pt_price - t.entry_price)) /
        (Math.abs(t.entry_price - t.stop_price))).toFixed(2);
      return `<div>PT${t.pt_amount}: ${t.pt_price.toFixed(8)} (${t.pt_status || 'PENDING'})
                    <span style="color: #ffff00"> R:R ${rr}</span></div>`;
    }).join('')}
    `;

    document.body.appendChild(menu);
  }



  console.log("Current Exchange", exchange)
  console.log("Selected Product", selectedProduct.product_id)
  console.log("Fills", all_fills)
  // all_fills.forEach((fill)=> {
  //   console.log(fill.product_id, selectedProduct.product_id, fill.product_id == selectedProduct.product_id)
  // })
  console.log("Orders", all_orders)
  console.log("Current Fills", current_fills)
  console.log("Current Orders", current_orders)
  console.log("All Trades", all_trades)
  // console.log("Current Trades", current_trades)

  function connectToBackend() {
    const backendURL = "http://192.168.0.22:31337";
    console.log("Connecting to SSE at:", backendURL);

    const eventSource = new EventSource(`${backendURL}/trigger/stream`);

    eventSource.onopen = (event) => {
      console.log("SSE Connection opened:", event);
    };

    eventSource.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        switch (message.event) {
          case 'price':
            // console.log("Price:", message) // Passes Test
            updateChartPrice(message.data);
            break;
          case 'candle':
            // console.log("Candle:", message, "\nSelected_Product:", selectedProduct, "\nExchange:",exchange, selectedTimeframe) // Passes Test, need to filter out to only get the product_timeframe
            let parsed_product = `${selectedProduct.product_id}_${selectedTimeframe.TF}_${exchange.Name}`.toLowerCase().replace("-", "_")
            console.log(parsed_product, message.data.ProductID)
            updateChart(message.data);
            break;
          case 'trigger':
            console.log("Trigger:", message);
            if (current_triggers) {
              // Find and update the triggered trigger
              const triggerIndex = current_triggers.findIndex(t => t.id === message.data.id);
              if (triggerIndex !== -1) {
                if (message.data.status === 'triggered') {
                  // Remove triggered trigger from array
                  current_triggers.splice(triggerIndex, 1);
                } else {
                  // Update trigger data
                  current_triggers[triggerIndex] = message.data;
                }
                // Redraw the chart to reflect the changes
                drawCandlestickChart(stockData, start, end);
              }
            }
            break;

        }
      } catch (err) {
        console.error("Error processing message:", err, "Raw data:", event.data);
      }
    };




    eventSource.onerror = (error) => {
      console.error("SSE connection error:", error);
      setTimeout(() => {
        console.log("Attempting to reconnect...");
        connectToBackend();
      }, 5000);
    };

    eventSource.addEventListener('candle', (event) => {
      try {
        const candleUpdate = JSON.parse(event.data)
        console.log("Raw Candle From Stream", event.data)
        console.log("Candle Update:", {
          product: candleUpdate.product_id,
          open: candleUpdate.Open,
          high: candleUpdate.High,
          low: candleUpdate.Low,
          close: candleUpdate.Close,
          volume: candleUpdate.Volume,
          time: new Date(candleUpdate.Timestamp * 1000).toLocaleTimeString(),
        })
        updateChart(candleUpdate)
      } catch (err) {
        console.error("Error processing candle update:", err)
      }
    })
  }

  function updateChartPrice(priceUpdate) {
    if (candleUpdate.product_id !== selectedProduct.product_id) {
      return
    }

    stockData.push({
      Timestamp: candleUpdate.timestamp,
      Open: candleUpdate.open,
      High: candleUpdate.high,
      Low: candleUpdate.low,
      Close: candleUpdate.close,
      Volume: candleUpdate.volume
    })

    if (stockData.length > end) {
      stockData.shift()
    }

    drawCandlestickChart(stockData, start, end)
  }

  function updateChartPrice(priceUpdate) {
    // console.log("Update Chart Price")

    if (priceUpdate.product_id !== selectedProduct.product_id) {
      return;
    }

    const latestPrice = priceUpdate.price;

    // Draw base chart first
    drawCandlestickChart(stockData, start, end);

    // Calculate price line position
    const width = canvas.width;
    const height = canvas.height;
    const margin = 50;

    const minPrice = Math.min(...stockData.slice(start, end).map(d => d.Low));
    const maxPrice = Math.max(...stockData.slice(start, end).map(d => d.High));

    const priceY = height - margin - ((latestPrice - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

    // Draw price line
    ctx.beginPath();
    ctx.moveTo(margin, priceY);
    ctx.lineTo(width - margin, priceY);
    ctx.strokeStyle = '#00ff00';
    ctx.setLineDash([5, 3]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Add price label
    ctx.fillStyle = '#00ff00';
    ctx.font = '12px Arial';
    ctx.fillText(`${latestPrice.toFixed(5)}`, width - 100, priceY - 5);
  }

  function updateChart(candleUpdate) {
    // Convert underscores to dashes in ProductID
    const formattedProductID = candleUpdate.ProductID.replace(/_/g, '-');
    console.log("|", candleUpdate.ProductID, "\n", selectedProduct)

    const newCandle = {
      Timestamp: candleUpdate.Timestamp,
      Open: candleUpdate.Open,
      High: candleUpdate.High,
      Low: candleUpdate.Low,
      Close: candleUpdate.Close,
      Volume: candleUpdate.Volume
    };

    // Check if candle with same timestamp exists
    const existingIndex = stockData.findIndex(candle => candle.Timestamp === candleUpdate.Timestamp);
    // console.log(existingIndex)

    if (existingIndex !== -1) {
      // Update existing candle
      stockData[existingIndex] = newCandle;
    } else {
      // Add new candle
      stockData.push(newCandle);

      // If we're at the end of the view, shift the window
      if (end === stockData.length - 1) {
        start++;
        end++;
      }
    }

    // Sort candles by timestamp to ensure proper order
    stockData.sort((a, b) => a.Timestamp - b.Timestamp);

    // Redraw chart with updated data
    drawCandlestickChart(stockData, start, end);
  }


  function showTriggerNotification(trigger) {
    const notification = document.createElement('div')
    notification.className = 'trigger-notification'
    notification.innerHTML = `
      <div class="notification-content">
        <strong>${trigger.product_id}</strong>
      </div>
    `
    document.body.appendChild(notification)

    setTimeout(() => notification.remove(), 5000)
  }

  function drawToolbar(ctx, width, height, margin, minPrice, maxPrice) {
    let activeLineIndex = -1;
    draw_lines.forEach((line, index) => {
      // Convert price back to Y coordinate
      const y = height - margin - ((line.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

      if (line.type === 'trigger') {
        ctx.setLineDash([5, 5])
      } else {
        ctx.setLineDash([])
      }

      ctx.beginPath();
      ctx.moveTo(margin, y);
      ctx.lineTo(width - margin, y);
      ctx.strokeStyle = line.color || 'yellow';
      ctx.stroke();

      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      if (line.type === 'trigger') {
        const lastCandle = stockData[stockData.length - 1]
        const currentPrice = lastCandle.Close
        const triggerType = line.price > currentPrice ? 'Trigger Above' : 'Trigger Below'
        ctx.fillText(`${triggerType}: ${line.price.toFixed(8)}`, width - 200, y - 5)
      } else {
        ctx.fillText(`${line.type ? line.type + ' - ' : ''}${line.price.toFixed(2)}`, width - 120, y - 5);
      }
    });

    if (currentTool === 'line' && drawingStart) {
      ctx.beginPath();
      ctx.moveTo(margin, drawingStart.y);
      ctx.lineTo(width - margin, drawingStart.y);
      ctx.strokeStyle = 'yellow';
      ctx.stroke();
    } else if (currentTool === 'box' && drawingStart) {
      ctx.beginPath();
      ctx.rect(drawingStart.x, drawingStart.y, mouseX - drawingStart.x, mouseY - drawingStart.y);
      ctx.strokeStyle = 'yellow';
      ctx.stroke();
    }
  }

  function handleMouseMove(e, chartState, tradeGroups) {
    fillHoverHandler(e, chartState)
    orderHoverHandler(e, chartState)
    tradeHoverHandler(e, chartState, tradeGroups)
    lineHoverHandler(e, chartState)
  }

  canvas.addEventListener('mousemove', (e) => handleMouseMove(e, chartState, tradeGroups))

  canvas.addEventListener('mouseleave', function (event) {
    // console.log("Canvas Leave");

    // Get mouse position
    const mouseX = event.clientX;
    const mouseY = event.clientY;

    // Get canvas and menu boundaries
    const canvasRect = canvas.getBoundingClientRect();
    const menu = document.querySelector('.order-menu');
    const menuRect = menu ? menu.getBoundingClientRect() : null;

    // Check if mouse is still inside canvas or menu
    const isMouseInCanvas =
      mouseX >= canvasRect.left &&
      mouseX <= canvasRect.right &&
      mouseY >= canvasRect.top &&
      mouseY <= canvasRect.bottom;

    const isMouseInMenu =
      menuRect &&
      mouseX >= menuRect.left &&
      mouseX <= menuRect.right &&
      mouseY >= menuRect.top &&
      mouseY <= menuRect.bottom;

    if (!isMouseInCanvas && !isMouseInMenu) {
      // console.log("Mouse has left both canvas and menu");
      document.querySelectorAll('.order-menu').forEach(el => el.remove());
    }
  });

  function drawCandlestickChart(data, start, end) {

    // Set canvas size and clear
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Chart dimensions
    const width = canvas.width;
    const height = canvas.height;
    const margin = 50;
    const visibleData = data.slice(start, end);
    const candleWidth = (width - 2 * margin) / visibleData.length;

    // Price range
    const minPrice = Math.min(...visibleData.map(d => d.Low));
    const maxPrice = Math.max(...visibleData.map(d => d.High));

    // Draw candlesticks
    visibleData.forEach((d, i) => {
      const x = margin + i * candleWidth;
      const openY = height - margin - ((d.Open - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
      const closeY = height - margin - ((d.Close - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
      const highY = height - margin - ((d.High - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
      const lowY = height - margin - ((d.Low - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

      // Draw candlestick
      ctx.beginPath();
      ctx.moveTo(x + candleWidth / 2, highY);
      ctx.lineTo(x + candleWidth / 2, lowY);
      ctx.strokeStyle = 'gray';
      ctx.stroke();

      ctx.beginPath();
      ctx.rect(x, Math.min(openY, closeY), candleWidth, Math.abs(openY - closeY));
      ctx.fillStyle = d.Close >= d.Open ? 'gray' : 'gray';
      ctx.strokeStyle = 'black';
      ctx.fill();
      ctx.stroke();
    });

    // Draw fills
    if (current_fills) {
      current_fills.forEach(fill => {
        const fillTime = new Date(fill.time).getTime() / 1000;
        const firstCandleTime = visibleData[0].Timestamp;
        const timeRange = visibleData[visibleData.length - 1].Timestamp - firstCandleTime;
        const xPosition = margin + ((fillTime - firstCandleTime) / timeRange) * (width - 2 * margin);
        const fillY = height - margin - ((fill.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

        ctx.beginPath();
        ctx.arc(xPosition, fillY, 4, 0, 2 * Math.PI);
        ctx.fillStyle = fill.side.toLowerCase() === 'buy' ? 'lime' : 'red';
        ctx.fill();
      });
    }

    // Draw orders
    if (current_orders) {
      current_orders.forEach(order => {
        const orderY = height - margin - ((order.Price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
        ctx.beginPath();
        ctx.moveTo(margin, orderY);
        ctx.lineTo(width - margin, orderY);
        ctx.strokeStyle = order.Side.toLowerCase() === 'buy' ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
        ctx.stroke();
      });
    }

    // Draw trade groups
    tradeGroups = {};

    if (current_trades) {
      current_trades.forEach(trade => {
        if (!tradeGroups[trade.group_id]) {
          tradeGroups[trade.group_id] = [];
        }
        tradeGroups[trade.group_id].push(trade);
      });

      Object.values(tradeGroups).forEach(trades => {
        // Calculate Y positions for entry/stop/targets
        const entryY = height - margin - ((trades[0].entry_price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
        const stopY = height - margin - ((trades[0].stop_price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
        const ptYs = trades.map(trade =>
          height - margin - ((trade.pt_price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin)
        );

        // Draw entry line
        ctx.beginPath();
        ctx.moveTo(margin, entryY);
        ctx.lineTo(width - margin, entryY);
        ctx.strokeStyle = trades[0].entry_status === 'FILLED' ? 'rgba(0, 255, 0, 0.8)' : 'rgba(0, 255, 0, 0.5)';
        ctx.stroke();

        // Draw stop loss line
        ctx.beginPath();
        ctx.moveTo(margin, stopY);
        ctx.lineTo(width - margin, stopY);
        ctx.strokeStyle = trades[0].stop_status === 'FILLED' ? 'rgba(255, 0, 0, 0.8)' : 'rgba(255, 0, 0, 0.5)';
        ctx.stroke();

        // Draw profit target lines
        trades.forEach((trade, i) => {
          const ptY = ptYs[i];
          ctx.beginPath();
          ctx.moveTo(margin, ptY);
          ctx.lineTo(width - margin, ptY);
          ctx.strokeStyle = trade.pt_status === 'FILLED' ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 255, 0, 0.5)';
          ctx.stroke();
        });

        // Draw connecting lines between targets
        ctx.beginPath();
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ptYs.forEach((ptY, i) => {
          if (i > 0) {
            ctx.moveTo(margin, ptYs[i - 1]);
            ctx.lineTo(width - margin, ptY);
          }
        });
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw R:R ratios
        trades.forEach((trade, i) => {
          const ptY = ptYs[i];
          const riskAmount = Math.abs(trade.entry_price - trade.stop_price);
          const rewardAmount = Math.abs(trade.pt_price - trade.entry_price);
          const rrRatio = (rewardAmount / riskAmount).toFixed(2);

          ctx.fillStyle = 'white';
          ctx.font = '12px Arial';
          ctx.fillText(`R:R ${rrRatio}`, width - 80, ptY - 5);
        });
      });
    }

    // Draw triggers
    if (current_triggers) {
      current_triggers.forEach(trigger => {
        // Skip triggered triggers
        if (trigger.status === 'triggered') {
          return;
        }

        const triggerY = height - margin - ((trigger.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

        // Draw the trigger line
        ctx.beginPath();
        ctx.moveTo(margin, triggerY);
        ctx.lineTo(width - margin, triggerY);
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = '#ff00ff';
        ctx.stroke();
        ctx.setLineDash([]);

        // Add label
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        const triggerType = trigger.type === 'price_above' ? 'Trigger Above' : 'Trigger Below';
        ctx.fillText(`${triggerType}: ${trigger.price.toFixed(8)}`, width - 200, triggerY - 5);
      });
    }



    // Add event listeners with chart state
    updateChartState(ctx, width, height, margin, minPrice, maxPrice)

    drawToolbar(ctx, width, height, margin, minPrice, maxPrice);
    drawCrosshair(ctx, width, height, margin, minPrice, maxPrice);

    return { ctx, width, height, margin, minPrice, maxPrice };
  }

  function isMouseNearLine(mouseY, lineY, threshold = 5) {
    return Math.abs(mouseY - lineY) < threshold;
  }


  function showLineMenu(x, y) {
    const menu = document.getElementById('lineMenu');
    const line = draw_lines[activeLineIndex];

    // Calculate line's Y position using stored chartState
    if (chartState) {
      const lineY = chartState.height - chartState.margin -
        ((line.price - chartState.minPrice) /
          (chartState.maxPrice - chartState.minPrice)) *
        (chartState.height - 2 * chartState.margin);

      menu.style.display = 'block';
      menu.style.left = `${x}px`;
      menu.style.top = `${lineY}px`;
    }
  }

  function cancelTrigger(triggerID) {
    fetch('/delete-trigger', {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ trigger_id: triggerID })
    })
      .then(response => response.json())
      .then(data => {
        console.log('Trigger cancelled:', data)
        current_triggers = current_triggers.filter(triggers => triggers.id !== triggerID)
        drawCandlestickChart(stockData, start, end)
      })
      .catch(error => {
        console.error('Error cancelling trigger:', error);
      })
  }

  function hideLineMenu() {
    const menu = document.getElementById('lineMenu');
    menu.style.display = 'none';
  }

  // Fix calculatePrice function
  function calculatePrice(y, height, margin, minPrice, maxPrice) {
    return maxPrice - ((y - margin) / (height - 2 * margin)) * (maxPrice - minPrice);
  }
  function drawCrosshair(ctx, width, height, margin, minPrice, maxPrice) {
    // Draw vertical line
    ctx.beginPath();
    ctx.moveTo(mouseX, margin);
    ctx.lineTo(mouseX, height - margin);
    ctx.strokeStyle = 'rgba(100,100,100,0.5)';
    ctx.stroke();

    // Draw horizontal line
    ctx.beginPath();
    ctx.moveTo(margin, mouseY);
    ctx.lineTo(width - margin, mouseY);
    ctx.strokeStyle = 'rgba(100,100,100,0.5)';
    ctx.stroke();

    // Calculate price - fixed formula to match the candlestick scaling
    var price = minPrice + ((height - margin - mouseY) / (height - 2 * margin)) * (maxPrice - minPrice);
    ctx.fillStyle = 'white';
    ctx.fillText(price.toFixed(2), width - 40, mouseY - 5);
  }


  // Initial draw
  drawCandlestickChart(stockData, start, end);

  // Add event listeners for zooming and panning
  document.getElementById('chartContainer').addEventListener('wheel', function (event) {
    event.preventDefault();
    if (event.deltaY < 0) { // Zoom in
      if (end - start > zoomFactor) {
        start += zoomFactor;
        end -= zoomFactor;
      }
    } else { // Zoom out
      start = Math.max(0, start - zoomFactor);
      end = Math.min(stockData.length, end + zoomFactor);
    }
    drawCandlestickChart(stockData, start, end);
  });

  var isDragging = false;
  var startX;

  // Update mousedown event to store price instead of coordinates
  canvas.addEventListener('mousedown', function (event) {
    var rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;

    if (currentTool) {
      if (currentTool === 'line') {
        chartState = drawCandlestickChart(stockData, start, end);
        const price = calculatePrice(mouseY, chartState.height, chartState.margin, chartState.minPrice, chartState.maxPrice);
        draw_lines.push({
          price: price
        });
        console.log("Draw_Lines", draw_lines);
        drawCandlestickChart(stockData, start, end);
      }
      drawingStart = { x: mouseX, y: mouseY };
    } else {
      isDragging = true;
      startX = event.clientX;
      canvas.style.cursor = 'grabbing';
    }
  });

  // Fix the calculatePrice function
  function calculatePrice(y, height, margin, minPrice, maxPrice) {
    return maxPrice - ((y - margin) / (height - 2 * margin)) * (maxPrice - minPrice);
  }

  canvas.addEventListener('mouseup', function () {
    console.log("MouseUp")
    if (currentTool) {
      drawingStart = null
      if (currentTool === 'box') {
        console.log(" - _Box end", mouseX, mouseY)
      }
    } else {
      isDragging = false;
      canvas.style.cursor = 'crosshair';
    }
  });

  canvas.addEventListener('mouseleave', function () {
    // console.log("Canvas Leave2")
    isDragging = false;
    canvas.style.cursor = 'crosshair';
  });

  canvas.addEventListener('click', function (event) {
    console.log("Line Clicked", draw_lines)
    if (activeLineIndex >= 0 && draw_lines[activeLineIndex]) {
      showLineMenu(event.pageX, event.pageY);
      console.log("Line clicked - Price:", draw_lines[activeLineIndex].price);
      console.log("Line type", draw_lines[activeLineIndex].type)
      if (draw_lines[activeLineIndex].type) {
        console.log("Line type:", draw_lines[activeLineIndex].type);
      }
    }
  });

  canvas.addEventListener('mousemove', function (event) {
    var rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;


    if (isDragging) {
      var dx = event.clientX - startX;
      var panFactor = Math.floor(dx / 10);
      if (panFactor !== 0) {
        start = Math.max(0, start - panFactor);
        end = Math.min(stockData.length, end - panFactor);
        startX = event.clientX;
        drawCandlestickChart(stockData, start, end);
      }
    } else {
      drawCandlestickChart(stockData, start, end);
    }
  });

  // Redraw on window resize
  window.addEventListener('resize', function () {
    chartState = drawCandlestickChart(stockData, start, end);
  });

  document.getElementById('line').addEventListener('click', function () {
    console.log("Line Selected")
    if (currentTool == 'line' || currentTool == 'box') {
      currentTool = null
    }
    else {

      currentTool = 'line'
    }
  })
  document.getElementById('box').addEventListener('click', function () {
    if (currentTool == 'line' || currentTool == 'box') {
      currentTool = null
    }
    else {
      console.log("Box Selected")
      currentTool = 'box'
    }
  })
  document.querySelectorAll('.line-menu-item').forEach(item => {
    item.addEventListener('click', function (e) {
      const action = this.dataset.action;
      if (activeLineIndex >= 0 && draw_lines[activeLineIndex]) {
        const line = draw_lines[activeLineIndex];

        switch (action) {
          case 'trigger':
            const lastCandle = stockData[stockData.length - 1]
            const currentPrice = lastCandle.Close

            line.type = 'trigger';
            line.color = '%ff00ff';

            const triggerData = {
              product_id: selectedProduct.product_id,
              type: line.price > currentPrice ? 'price_above' : 'price_below',
              price: parseFloat(line.price),
              status: 'active',
              xch_id: exchange.ID
            }

            fetch('create-trigger', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(triggerData)
            })
              .then(response => response.json())
              .then(data => {
                console.log('Trigger Created: ', data)
                line.triggerId = data.id
              })
              .catch(error => {
                console.log('Error creating trigger:', error)
              })
            break;

          case 'entry':
            line.type = 'entry';
            line.color = '#00ff00';
            console.log("Entry line at price:", line.price);
            window.currentTrade = {
              entry: line.price,
              productId: selectedProduct.product_id
            };
            break;

          case 'pt':
            line.type = 'pt';
            line.color = '#ffff00';
            console.log("Profit target at price:", line.price);
            if (window.currentTrade && window.currentTrade.entry) {
              window.currentTrade.target = line.price;
            }
            break;

          case 'stop':
            line.type = 'stop';
            line.color = '#ff0000';
            console.log("Stop loss at price:", line.price);
            if (window.currentTrade && window.currentTrade.entry) {
              window.currentTrade.stop = line.price;
            }
            break;

          case 'delete':
            draw_lines.splice(activeLineIndex, 1);
            console.log("Line deleted at price:", line.price);
            break;

          case 'create':
            const entryLine = draw_lines.find(line => line.type === 'entry')
            const stopLine = draw_lines.find(line => line.type === 'stop')
            const targetLine = draw_lines.find(line => line.type === 'pt')

            if (!entryLine || !stopLine || !targetLine) {
              alert('Please set entry, stop loss, and profit target levels before creating trade')
              return
            }

            const tradeSetup = {
              entry: entryLine.price,
              size: 500,
              stop: stopLine.price,
              target: targetLine.price,
              productId: selectedProduct.product_id
            }
            createTradeGroup(tradeSetup)
            console.log("Trade group created", tradeSetup)
            break;
        }
      }

      hideLineMenu();
      drawCandlestickChart(stockData, start, end);
    });
  });

  function createTradeGroup(trade) {
    const side = trade.target > trade.entry ? 'BUY' : 'SELL';
    const riskAmount = Math.abs(trade.entry - trade.stop);
    const rewardAmount = Math.abs(trade.target - trade.entry);
    const riskRewardRatio = parseFloat((rewardAmount / riskAmount).toFixed(2));

    const ptLines = draw_lines.filter(line => line.type === "pt");
    const profitTargets = ptLines.map(line => parseFloat(line.price))

    const tradeData = {
      product_id: trade.productId,
      side: side,
      size: parseFloat(trade.size || "0"),
      entry_price: parseFloat(trade.entry),
      stop_price: parseFloat(trade.stop),
      profit_targets: profitTargets,
      risk_reward: riskRewardRatio,
      xch_id: exchange.ID
    };

    fetch('/bracket-order', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(tradeData)
    })
      .then(response => response.json())
      .then(data => {
        console.log('Trade group created:', data);
      })
      .catch(error => {
        console.error('Error creating trade:', error);
      });
  }

  document.addEventListener('click', function (e) {
    if (!e.target.closest('#lineMenu') && !e.target.closest('#candlestickChart')) {
      hideLineMenu();
    }
  });

  drawCandlestickChart(stockData, start, end);
  document.addEventListener('DOMContentLoaded', () => {
    connectToBackend();

    // Initialize Bootstrap tabs if they exist
    const tabElements = document.querySelectorAll('[data-bs-toggle="tab"]');
    if (tabElements.length > 0) {
      tabElements.forEach(el => {
        new bootstrap.Tab(el);
      });
    }
  });

</script>
{{end}}