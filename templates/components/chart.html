{{define "chart"}}

<div id="chartContainer" style="width: 100%; height: calc(100vh - 400px);">
  <div id="toolbar">
    <button id="line" class="btn btn-sm btn-secondary">Line</button>
    <button id="box" class="btn btn-sm btn-secondary">Box</button>
    <button id="trigger" class="btn btn-sm btn-secondary">Trigger</button>
  </div>
  <canvas id="candlestickChart"></canvas>
  <div id="lineMenu" class="line-menu" style="display: none;">
    <div class="line-menu-item" data-action="entry">Trade Entry</div>
    <div class="line-menu-item" data-action="pt">Profit Target</div>
    <div class="line-menu-item" data-action="stop">Stop Loss</div>
    <div class="line-menu-item" data-action="trigger">Trigger</div>
    <div class="line-menu-item" data-action="delete">Delete</div>
    <div class="line-menu-item create-trade-btn" data-action="create">Create Trade</div>
  </div>

  <div id="triggerMenu" , class="trigger-menu" style="display: none;">
    <div class="trigger-menu-item" data-action="entry">Delete</div>
    <div class="trigger-menu-item" data-action="entry">Trade Entry</div>
    <div class="trigger-menu-item" data-action="entry">Trade Entry</div>
    <div class="trigger-menu-item" data-action="entry">Trade Entry</div>
    <div class="trigger-menu-item" data-action="entry">Trade Entry</div>

  </div>

</div>

<style>
  #chartContainer {
    position: relative;
    width: 100vw;
    margin-left: calc(-50vw + 50%);
  }

  #candlestickChart {
    width: 100% !important;
    height: 100% !important;
    cursor: grab;
  }

  .line-menu {
    position: absolute;
    background: #212529;
    border: 1px solid #444;
    border-radius: 4px;
    padding: 5px 0;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
  }

  .line-menu-item {
    padding: 8px 15px;
    color: white;
    cursor: pointer;
    font-size: 14px;
    white-space: nowrap;
  }

  .line-menu-item:hover {
    background: #2c3034;
  }

  .create-trade-btn {
    background-color: #198754;
    color: white;
    font-weight: bold;
    border-top: 1px solid #444;
    margin-top: 5px;
  }

  .create-trade-btn:hover {
    background-color: #157347;
  }

  .trade-menu {
    position: absolute;
    background: rgba(33, 37, 41, 0.95);
    border: 1px solid #444;
    border-radius: 4px;
    padding: 10px;
    z-index: 1000;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    color: white;
    font-size: 12px;
    pointer-events: none;
    max-width: 250px;
  }

  .order-menu {
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 10px;
    border-radius: 4px;
    pointer-events: auto;
  }

  .trigger-menu {
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 10px;
    border-radius: 4px;
    pointer-events: auto;
    font-size: 12px;
  }

  .cancel-button {
    margin-top: 5px;
    padding: 5px;
    background: #ff4444;
    text-align: center;
    cursor: pointer;
    border-radius: 3px;
  }

  .cancel-button:hover {
    background: #ff6666;
  }

  .trigger-menu {
    background-color: #333;
    color: white;
    padding: 10px;
    border: 1px solid #666;
    border-radius: 4px;
  }

  .trigger-menu-item {
    padding: 5px;
    cursor: pointer;
    border-top: 1px solid #444;
    margin-top: 5px;
  }

  .trigger-menu-item:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .trigger-submenu {
    position: absolute;
    background-color: #333;
    color: white;
    padding: 10px;
    border: 1px solid #666;
    border-radius: 4px;
    z-index: 1001;
    min-width: 150px;
  }

  .trigger-submenu-item {
    padding: 5px;
    cursor: pointer;
    border-top: 1px solid #444;
    margin-top: 5px;
  }

  .trigger-submenu-item:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .setup-section {
    margin: 15px 0;
    padding: 10px;
    border: 1px solid #444;
    border-radius: 4px;
  }

  .pt-item {
    margin: 8px 0;
    padding: 5px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 4px;
  }

  .execute-btn {
    width: 100%;
    padding: 10px;
    background: #198754;
    color: white;
    border: none;
    border-radius: 4px;
    margin-top: 20px;
    cursor: pointer;
  }

  .execute-btn:hover {
    background: #157347;
  }

  #trade-setup-tab {
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
  }

  #trade-setup-tab:hover {
    background-color: #444;
  }

  #trade-setup-sidebar {
    box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
  }

  .trigger-details {
    background: rgba(255, 255, 255, 0.05);
    padding: 8px;
    border-radius: 4px;
    margin-top: 5px;
  }

  .trigger-details>div {
    margin: 4px 0;
  }

  .risk-calculator {
    background: rgba(255, 255, 255, 0.05);
    padding: 10px;
    border-radius: 4px;
    margin-top: 5px;
  }

  #riskSlider {
    width: 100%;
    margin: 10px 0;
  }

  .risk-slider {
    -webkit-appearance: none;
    width: 100%;
    height: 10px;
    background: #444;
    border-radius: 5px;
    outline: none;
    margin: 10px 0;
  }

  .risk-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    background: #666;
    border-radius: 50%;
    cursor: grab;
    transition: background 0.2s;
  }

  .risk-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    background: #666;
    border-radius: 50%;
    cursor: grab;
  }

  .trigger-chain-item {
    background: rgba(255, 255, 255, 0.05);
    padding: 8px;
    margin: 8px 0;
    border-radius: 4px;
  }

  .trigger-order {
    font-weight: bold;
    margin-bottom: 5px;
  }

  .trigger-settings {
    display: flex;
    gap: 5px;
    margin-top: 5px;
  }

  .trigger-chain-item input,
  .trigger-chain-item select {
    background: #444;
    color: white;
    border: 1px solid #666;
    padding: 3px;
    border-radius: 3px;
    margin: 2px 0;
  }

  .trigger-details {
    background: rgba(255, 255, 255, 0.05);
    padding: 10px;
    margin: 8px 0;
    border-radius: 4px;
  }

  .trigger-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }

  .trigger-order {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .trigger-order button {
    background: #444;
    border: none;
    color: white;
    padding: 2px 5px;
    border-radius: 3px;
    cursor: pointer;
  }

  .trigger-order button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .trigger-content select,
  .trigger-content input {
    background: #444;
    color: white;
    border: 1px solid #666;
    padding: 3px;
    border-radius: 3px;
    margin: 2px 0;
  }

  .trigger-settings {
    display: flex;
    gap: 5px;
    margin: 5px 0;
  }

  .btn-remove {
    background: none;
    border: none;
    color: #ff4444;
    cursor: pointer;
  }
</style>

<script>
  var stockData = {{.Candles }};
  var selectedProduct = {{.SelectedProduct }};
  var exchange = {{.SelectedExchange }};
  var selectedTimeframe = {{.SelectedTimeframe }}
  var portfolioSize = {{.TotalValue }}
  var all_fills = exchange.Fills;
  var all_orders = exchange.Orders;
  var all_trades = exchange.Trades;
  var all_triggers = exchange.Triggers || [];
  console.log("INITIALIZING")
  let tradeGroups = {};

  var end = stockData.length
  var start = Math.max(0, end - 250);
  var zoomFactor = 10;


  const canvas = document.getElementById('candlestickChart');
  const ctx = canvas.getContext('2d');

  var chartState = null;

  function updateChartState(ctx, width, height, margin, minPrice, maxPrice) {
    chartState = {
      ctx,
      width,
      height,
      margin,
      minPrice,
      maxPrice
    }
  }

  var mouseX = 0;
  var mouseY = 0;
  var currentTool = null
  var drawingStart = null
  var draw_boxes = []
  var draw_lines = []
  var activeLineIndex = -1;

  console.log("Triggers", all_triggers)

  var current_fills = all_fills.filter(product => product.product_id === selectedProduct.product_id)
  var current_orders = all_orders.filter(product => product.ProductID === selectedProduct.product_id)
  var current_trades = all_trades.filter(trade => trade.product_id === selectedProduct.product_id)
  var current_triggers = all_triggers.filter(trigger => trigger.product_id === selectedProduct.product_id)

  const fillHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;

    current_fills.forEach(fill => {
      const fillTime = new Date(fill.time).getTime() / 1000;
      const firstCandleTime = stockData[start].Timestamp;
      const timeRange = stockData[end - 1].Timestamp - firstCandleTime;
      const xPosition = chartState.margin + ((fillTime - firstCandleTime) / timeRange) * (chartState.width - 2 * chartState.margin);
      const fillY = chartState.height - chartState.margin - ((fill.price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) * (chartState.height - 2 * chartState.margin);

      const distance = Math.sqrt(Math.pow(xPosition - mouseX, 2) + Math.pow(fillY - mouseY, 2));
      if (distance < 8) {
        chartState.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        chartState.ctx.fillRect(mouseX + 10, mouseY - 40, 120, 60);
        chartState.ctx.fillStyle = 'white';
        chartState.ctx.font = '12px Arial';
        chartState.ctx.fillText(`Fill Price: ${fill.price}`, mouseX + 15, mouseY - 20);
        chartState.ctx.fillText(`Size: ${fill.size}`, mouseX + 15, mouseY);
      }
    });
  };

  const orderHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    current_orders.forEach(order => {
      const orderY = chartState.height - chartState.margin -
        ((order.Price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
        (chartState.height - 2 * chartState.margin);

      if (Math.abs(mouseY - orderY) < 5) {
        // Check if a menu already exists
        let existingMenu = document.querySelector('.order-menu');

        if (!existingMenu) {
          // Remove any existing menus
          document.querySelectorAll('.order-menu').forEach(el => el.remove());

          // Create a new menu
          const menu = document.createElement('div');
          menu.className = 'order-menu';
          menu.style.position = 'absolute';
          menu.style.left = `${e.pageX - 150}px`;
          menu.style.top = `${e.pageY - 10}px`;
          menu.style.zIndex = '1000';
          menu.style.pointerEvents = 'auto';

          // Populate menu content
          menu.innerHTML = `
          <div><strong>Order Details</strong></div>
          <div>Side: ${order.Side}</div>
          <div>Product: ${order.ProductID}</div>
          <div>Price: ${order.Price}</div>
          <div>Size: ${order.Size}</div>
          <div>Status: ${order.Status}</div>
          <div class="cancel-button" onclick="cancelOrder('${order.OrderID}')">Cancel Order</div>
        `;

          // Add hover behavior to prevent premature removal
          let isMouseOverMenu = false;

          // Keep track of hover state for the menu
          menu.addEventListener('mouseenter', () => {
            // console.log("Menu enter");
            isMouseOverMenu = true;
          });

          // Remove menu on mouse leave
          menu.addEventListener('mouseleave', function () {
            // console.log("Menu leave");
            this.remove(); // Remove the menu when the mouse leaves it
          });

          // Append the menu to the body
          document.body.appendChild(menu);
        }
      }
    });
  };

  const tradeHoverHandler = function (e, chartState, groups) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    Object.values(groups).forEach(trades => {
      trades.forEach(trade => {
        const entryY = chartState.height - chartState.margin -
          ((trade.entry_price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
          (chartState.height - 2 * chartState.margin);
        const stopY = chartState.height - chartState.margin -
          ((trade.stop_price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
          (chartState.height - 2 * chartState.margin);
        const ptY = chartState.height - chartState.margin -
          ((trade.pt_price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
          (chartState.height - 2 * chartState.margin);

        if (isMouseNearLine(mouseY, entryY) || isMouseNearLine(mouseY, stopY) || isMouseNearLine(mouseY, ptY)) {
          let existingMenu = document.querySelector('.trade-menu');

          if (!existingMenu) {
            document.querySelectorAll('.trade-menu').forEach(el => el.remove());

            const menu = document.createElement('div');
            menu.className = 'trade-menu';
            menu.style.position = 'absolute';
            menu.style.left = `${e.pageX - 150}px`;
            menu.style.top = `${e.pageY - 10}px`;
            menu.style.zIndex = '1000';
            menu.style.pointerEvents = 'auto';

            const groupTrades = groups[trade.group_id];
            menu.innerHTML = `
                        <div><strong>Trade Group ${trade.group_id}</strong></div>
                        <div>Side: ${trade.side}</div>
                        <div>Entry: ${trade.entry_price.toFixed(8)} (${trade.entry_status || 'PENDING'})</div>
                        <div>Stop: ${trade.stop_price.toFixed(8)} (${trade.stop_status || 'PENDING'})</div>
                        <div>Size: ${trade.size}</div>
                        <div>Created: ${new Date(trade.created_at).toLocaleString()}</div>
                        <div>Targets:</div>
                        ${groupTrades.map(t => {
              const rr = ((Math.abs(t.pt_price - t.entry_price)) /
                (Math.abs(t.entry_price - t.stop_price))).toFixed(2);
              return `<div>PT${t.pt_amount}: ${t.pt_price.toFixed(8)} (${t.pt_status || 'PENDING'})
                                    <span style="color: #ffff00"> R:R ${rr}</span></div>`;
            }).join('')}
                    `;

            menu.addEventListener('mouseenter', () => {
              // console.log("Trade Menu enter");
              menu.dataset.hovering = 'true';
            });

            menu.addEventListener('mouseleave', function () {
              // console.log("Trade Menu leave");
              this.remove();
            });

            document.body.appendChild(menu);
          }
        }
      });
    });
  };

  const lineHoverHandler = function (e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    let isNearLine = false;
    draw_lines.forEach((line, index) => {
      const lineY = chartState.height - chartState.margin -
        ((line.price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
        (chartState.height - 2 * chartState.margin);

      if (isMouseNearLine(mouseY, lineY)) {
        let existingMenu = document.querySelector('.line-menu');

        if (!existingMenu) {
          document.querySelectorAll('.line-menu').forEach(el => el.remove());

          const menu = document.createElement('div');
          menu.className = 'line-menu';
          menu.style.position = 'absolute';
          menu.style.left = `${e.pageX - 100}px`;
          menu.style.top = `${e.pageY - 10}px`;
          menu.style.display = 'block';
          menu.style.zIndex = '1000';
          menu.style.pointerEvents = 'auto';

          menu.innerHTML = `
                    <div class="line-menu-item" data-action="entry">Trade Entry</div>
                    <div class="line-menu-item" data-action="pt">Profit Target</div>
                    <div class="line-menu-item" data-action="stop">Stop Loss</div>
                    <div class="line-menu-item" data-action="trigger">Trigger</div>
                    <div class="line-menu-item" data-action="delete">Delete</div>
                    <div class="line-menu-item create-trade-btn" data-action="create">Create Trade</div>
                `;

          menu.addEventListener('mouseenter', () => {
            menu.dataset.hovering = 'true';
          });

          menu.addEventListener('mouseleave', () => {
            menu.dataset.hovering = 'false';
            menu.remove();
          });

          // Add click handlers to menu items
          menu.querySelectorAll('.line-menu-item').forEach(item => {
            item.addEventListener('click', function (e) {
              const action = this.dataset.action;
              handleLineAction(action, draw_lines[activeLineIndex]);
              menu.remove();
              drawCandlestickChart(stockData, start, end);
            });
          });

          document.body.appendChild(menu);
        }

        canvas.style.cursor = 'pointer';
        isNearLine = true;
        activeLineIndex = index;
      }
    });

    if (!isNearLine) {
      canvas.style.cursor = 'default';
      activeLineIndex = -1;
      const menu = document.querySelector('.line-menu');
      if (menu && menu.dataset.hovering !== 'true') {
        menu.remove();
      }
    }
  };

  function createTradeSetupSidebar() {
    // Remove any existing sidebars first
    const existingSidebar = document.getElementById('trade-setup-sidebar');
    const existingTab = document.getElementById('trade-setup-tab');
    if (existingSidebar) existingSidebar.remove();
    if (existingTab) existingTab.remove();

    let currentRiskPercentage = 0.5;

    // Add CSS for slider
    const style = document.createElement('style');
    style.textContent = `
        .risk-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 10px;
            border-radius: 5px;
            background: #444;
            outline: none;
            margin: 10px 0;
        }

        .risk-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #666;
            cursor: pointer;
        }

        .risk-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #666;
            cursor: pointer;
        }
    `;
    document.head.appendChild(style);

    // Create collapsed sidebar tab
    const tab = document.createElement('div');
    tab.id = 'trade-setup-tab';
    tab.style.cssText = `
        position: fixed;
        right: 0;
        bottom: 0;
        background-color: #333;
        color: white;
        padding: 10px;
        border-radius: 4px 0 0 0;
        cursor: pointer;
        z-index: 1001;
    `;
    tab.innerHTML = '▶ Trade Setup';


    const sidebar = document.createElement('div');
    sidebar.id = 'trade-setup-sidebar';
    sidebar.style.cssText = `
        position: fixed;
        right: -350px;
        top: 0;
        bottom: 0;
        width: 350px;
        background-color: #333;
        color: white;
        padding: 15px;
        border-left: 1px solid #444;
        overflow-y: auto;
        z-index: 1000;
        transition: right 0.3s ease;
    `;


    window.toggleSidebar = function () {
      const isExpanded = sidebar.style.right === '0px';
      sidebar.style.right = isExpanded ? '-350px' : '0px';
      tab.innerHTML = isExpanded ? '▶ Trade Setup' : '◀ Trade Setup';

      // Get chart container
      const chartContainer = document.getElementById('chartContainer');
      if (chartContainer) {
        // Set margin and width together
        chartContainer.style.marginRight = isExpanded ? '0' : '350px';
        chartContainer.style.width = isExpanded ? '100%' : 'calc(100% - 350px)';
        chartContainer.style.transition = 'all 0.3s ease';

        // Redraw chart after transition to ensure proper sizing
        setTimeout(() => {
          drawCandlestickChart(stockData, start, end);
        }, 300);
      }
    };





    // Make updateRisk globally accessible
    window.updateRisk = function (value) {
      currentRiskPercentage = parseFloat(value);
      updateSidebarContent();
    };

    tab.addEventListener('click', window.toggleSidebar);

    function updateSidebarContent() {
      const trigger = window.currentTradeSetup?.trigger;
      console.log("")
      const entryLine = draw_lines.find(l => l.type === 'entry');
      const stopLine = draw_lines.find(l => l.type === 'stop');
      const ptLines = draw_lines.filter(l => l.type === 'pt');

      // Calculate risk if entry and stop are set
      let riskAmount = 0;
      let positionSize = 0;
      let stopLossRiskPercent = 0;

      if (entryLine && stopLine) {
        const entryPrice = entryLine.price;
        const stopPrice = stopLine.price;
        const priceDiff = Math.abs(entryPrice - stopPrice);

        // Calculate position sizing
        riskAmount = portfolioSize * (currentRiskPercentage / 100);
        positionSize = (riskAmount / priceDiff).toFixed(2);

        // Calculate stop loss risk percentage (price-based risk)
        stopLossRiskPercent = ((priceDiff / entryPrice) * 100).toFixed(2);
      }


      sidebar.innerHTML = `
            <div style="text-align: right;">
                <span onclick="toggleSidebar()" style="cursor: pointer; padding: 5px;">✕</span>
            </div>
            <h3>Trade Setup</h3>
            
            <div class="setup-section">
                <h4>Trigger Conditions</h4>
                ${window.currentTradeSetup?.chainedTriggers?.length > 0 ? `
    ${window.currentTradeSetup.chainedTriggers.map((trigger, index) => `
        <div class="trigger-details">
    <div class="trigger-header">
        <div class="trigger-order">
            <button onclick="moveTrigger(${index}, -1)" ${index === 0 ? 'disabled' : ''}>↑</button>
            <span>Trigger ${index + 1}</span>
            <button onclick="moveTrigger(${index}, 1)" ${index === window.currentTradeSetup.chainedTriggers.length - 1 ? 'disabled' : ''}>↓</button>
        </div>
        <button class="btn-remove" onclick="removeTrigger(${index})">✕</button>
    </div>
    <div class="trigger-settings">
        <select onchange="updateTriggerType(${trigger.id}, this.value)">
            <option value="price_above" ${trigger.type === 'price_above' ? 'selected' : ''}>Price Above</option>
            <option value="price_below" ${trigger.type === 'price_below' ? 'selected' : ''}>Price Below</option>
            <option value="closes_above" ${trigger.type === 'closes_above' ? 'selected' : ''}>Closes Above</option>
            <option value="closes_below" ${trigger.type === 'closes_below' ? 'selected' : ''}>Closes Below</option>
            <option value="wicks_above" ${trigger.type === 'wicks_above' ? 'selected' : ''}>Wicks Above</option>
            <option value="wicks_below" ${trigger.type === 'wicks_below' ? 'selected' : ''}>Wicks Below</option>
        </select>
    </div>
    <div>Price: ${trigger.price.toFixed(8)}</div>
    <div>Timeframe: ${trigger.timeframe || '1m'}</div>
    <div>Candles: ${trigger.candles || 1}</div>
    <div>Status: ${trigger.status}</div>
    <div class="trigger-settings">
        <select onchange="updateTriggerTimeframe(${trigger.id}, this.value)">
            <option value="1m" ${trigger.timeframe === '1m' ? 'selected' : ''}>1m</option>
            <option value="5m" ${trigger.timeframe === '5m' ? 'selected' : ''}>5m</option>
            <option value="15m" ${trigger.timeframe === '15m' ? 'selected' : ''}>15m</option>
            <option value="1h" ${trigger.timeframe === '1h' ? 'selected' : ''}>1h</option>
        </select>
        <input type="number" 
               value="${trigger.candles || 1}" 
               min="1" 
               onchange="updateTriggerCandles(${trigger.id}, this.value)"
               placeholder="Candles">
    </div>
</div>

    `).join('')}
` : '<div>No triggers set</div>'}

                <div style="margin-top: 10px;">
                    <small>Draw trigger lines on chart to add conditions</small>
                </div>
            </div>


            <div class="setup-section">
                <h4>Risk Calculator</h4>
                <div class="risk-calculator">
                    <div>Portfolio Size: $${portfolioSize.toLocaleString()}</div>
                    <div style="margin: 10px 0;">
                        <label>Risk %: <span id="riskValue">${currentRiskPercentage}</span>%</label>
                        <input type="range" 
                               class="risk-slider"
                               id="riskSlider" 
                               min="0.1" 
                               max="2" 
                               step="0.1" 
                               value="${currentRiskPercentage}"
                               oninput="updateRisk(this.value)">
                    </div>
                    ${entryLine && stopLine ? `
                        <div>Risk Amount: $${riskAmount.toFixed(2)}</div>
                    ` : '<div>Set entry and stop loss to calculate position size</div>'}
                </div>
            </div>

            <div class="setup-section">
                <h4>Entry <h4><button class="btn btn-sm btn-dark">(+)</button>
                ${entryLine ? `
                    <div>Price: ${entryLine.price.toFixed(8)}</div>
                    <div>Position Size: ${positionSize} units</div>
                ` : '<div>Not Set</div>'}
            </div>

            <div class="setup-section">
                  <h4>Stop Loss</h4>
                  ${stopLine ? `
                      <div>Price: ${stopLine.price.toFixed(8)}</div>
                      <div>Risk: ${currentRiskPercentage}%</div>
                  ` : '<div>Not Set</div>'}
                
            </div>

            <div class="setup-section">
                <h4>Profit Targets</h4>,
      
                ${ptLines.length > 0 ? ptLines.map((pt, i) => `
                    <div class="pt-item">
                        <div>Target ${i + 1}: ${pt.price.toFixed(8)}</div>
                        <div>R:R ${calculateRR(entryLine?.price, stopLine?.price, pt.price)}</div>
                    </div>
                `).join('') : '<div>Not Set</div>'}
            </div>

            ${entryLine && stopLine && ptLines.length > 0 ? `
                <button class="execute-btn" onclick="executeTradeSetup()">
                    Execute Trade Setup
                </button>
            ` : ''}
        `;
    }

    document.body.appendChild(tab);
    document.body.appendChild(sidebar);

    // Reset main content margin when sidebar is created
    const chartContainer = document.getElementById('chartContainer');
    if (chartContainer) {
      chartContainer.style.marginRight = '0';
    }


    // Initial render
    updateSidebarContent();
    // Return refresh function
    return () => {
      updateSidebarContent();
      sidebar.style.right = '0px'; // Changed from left to right
    };
  }


  function addChainedTrigger() {
    if (!window.currentTradeSetup) {
      window.currentTradeSetup = { chainedTriggers: [] };
    }
    if (!window.currentTradeSetup.chainedTriggers) {
      window.currentTradeSetup.chainedTriggers = [];
    }

    window.currentTradeSetup.chainedTriggers.push({
      type: 'price_above',
      price: 0,
      timeframe: '1m',
      candles: 1
    });

    const updateSidebar = createTradeSetupSidebar();
    updateSidebar();
  }

  function updateTriggerCondition(index, value) {
    window.currentTradeSetup.chainedTriggers[index].type = value;
    const updateSidebar = createTradeSetupSidebar();
    updateSidebar();
  }

  function updateTriggerPrice(index, value) {
    window.currentTradeSetup.chainedTriggers[index].price = parseFloat(value);
    const updateSidebar = createTradeSetupSidebar();
    updateSidebar();
  }

  function updateTriggerTimeframe(index, value) {
    window.currentTradeSetup.chainedTriggers[index].timeframe = value;
    const updateSidebar = createTradeSetupSidebar();
    updateSidebar();
  }

  function updateTriggerCandles(index, value) {
    window.currentTradeSetup.chainedTriggers[index].candles = parseInt(value);
    const updateSidebar = createTradeSetupSidebar();
    updateSidebar();
  }

  function removeTrigger(index) {
    window.currentTradeSetup.chainedTriggers.splice(index, 1);
    const updateSidebar = createTradeSetupSidebar();
    updateSidebar();
  }



  function updateRisk(value) {
    window.updateRisk = function (value) {
      currentRiskPercentage = parseFloat(value);
      // Force full sidebar refresh
      const updateFn = createTradeSetupSidebar();
      updateFn();
      // Update chart to reflect any changes
      drawCandlestickChart(stockData, start, end);
    };
  }


  const updateSidebar = createTradeSetupSidebar();

  function handleLineAction(action, line) {
    switch (action) {
      case 'trigger':
        const lastCandle = stockData[stockData.length - 1];
        const currentPrice = lastCandle.Close;

        line.type = 'trigger';
        line.color = '#ff00ff';

        const triggerData = {
          product_id: selectedProduct.product_id,
          type: line.price > currentPrice ? 'price_above' : 'price_below',
          price: parseFloat(line.price),
          status: 'active',
          xch_id: exchange.ID
        };

        // Initialize currentTradeSetup if it doesn't exist
        if (!window.currentTradeSetup) {
          window.currentTradeSetup = {
            chainedTriggers: []
          };
        }

        // Add trigger to trade setup
        window.currentTradeSetup.chainedTriggers.push(triggerData);

        fetch('create-trigger', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(triggerData)
        })
          .then(response => response.json())
          .then(data => {
            console.log('Trigger Created: ', data);
            line.triggerId = data.id;
            // Update sidebar and push content
            const updateSidebar = createTradeSetupSidebar();
            updateSidebar();

            // Get chart container and adjust margin
            const chartContainer = document.getElementById('chartContainer');
            if (chartContainer) {
              chartContainer.style.marginRight = '350px';
              chartContainer.style.width = 'calc(100% - 350px)';
              chartContainer.style.transition = 'all 0.3s ease';

              // Redraw chart after transition
              setTimeout(() => {
                drawCandlestickChart(stockData, start, end);
              }, 300);
            }
          })
          .catch(error => {
            console.log('Error creating trigger:', error);
          });
        break;

      case 'entry':
        line.type = 'entry';
        line.color = '#00ff00';
        window.currentTrade = {
          entry: line.price,
          productId: selectedProduct.product_id
        };
        // Add same margin adjustment for entry
        const chartContainer = document.getElementById('chartContainer');
        if (chartContainer) {
          chartContainer.style.marginRight = '350px';
          chartContainer.style.width = 'calc(100% - 350px)';
          chartContainer.style.transition = 'all 0.3s ease';
          setTimeout(() => {
            drawCandlestickChart(stockData, start, end);
          }, 300);
        }
        break;

      case 'pt':
        line.type = 'pt';
        line.color = '#ffff00';
        if (window.currentTrade && window.currentTrade.entry) {
          window.currentTrade.target = line.price;
        }
        break;

      case 'stop':
        line.type = 'stop';
        line.color = '#ff0000';
        if (window.currentTrade && window.currentTrade.entry) {
          window.currentTrade.stop = line.price;
        }
        break;

      case 'delete':
        draw_lines.splice(activeLineIndex, 1);
        break;

      case 'create':
        const entryLine = draw_lines.find(l => l.type === 'entry');
        const stopLine = draw_lines.find(l => l.type === 'stop');
        const targetLine = draw_lines.find(l => l.type === 'pt');

        if (!entryLine || !stopLine || !targetLine) {
          alert('Please set entry, stop loss, and profit target levels before creating trade');
          return;
        }

        const tradeSetup = {
          entry: entryLine.price,
          size: 500,
          stop: stopLine.price,
          target: targetLine.price,
          productId: selectedProduct.product_id
        };
        createTradeGroup(tradeSetup);
        break;
    }
    updateSidebar()
  }

  function calculateRisk(entry, stop) {
    if (!entry || !stop) return 0;
    return (Math.abs(entry - stop) / entry * 100).toFixed(2)
  }

  function calculateRR(entry, stop, target) {
    if (!entry || !stop || !target) return 0;
    const risk = Math.abs(entry - stop)
    const reward = Math.abs(target - entry)
    return (reward / risk).toFixed(2)
  }

  function executeTradeSetup() {
    const entryLine = draw_lines.find(l => l.type === 'entry')
    const stopLine = draw_lines.find(l => l.type === 'stop')
    const ptLines = draw_lines.find(l => l.type === 'pt')
    const triggerLine = window.currentTradeSetup?.trigger

    const tradeData = {
      product_id: selectedProduct.product_id,
      size: parseFloat(document.getElementById('tradeSize').value),
      size: parseFloat(document.getElementById('tradeSize').value),
      entry_price: entryLine.price,
      stop_price: stopLine.price,
      profit_targets: ptLines.map(pt => pt.price),
      trigger_id: trigger?.id,
      xch_id: exchange.ID
    }

    fetch('/create-trade-setup', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSONL.stringify(tradeData)
    })
      .then(response => response.json())
      .then(data => {
        console.log('Trade setup created:', data)
        draw_lines = []
        window.currentTradeSetup = null
        drawCandlestickChart(stockData, start, end)
        updateSidebar()
      })
      .catch(error => console.error('Error', error))
  }

  function triggerHoverHandler(e, chartState) {
    const rect = canvas.getBoundingClientRect();
    const mouseY = e.clientY - rect.top;

    if (current_triggers) {
      current_triggers.forEach(trigger => {
        const triggerY = chartState.height - chartState.margin -
          ((trigger.price - chartState.minPrice) / (chartState.maxPrice - chartState.minPrice)) *
          (chartState.height - 2 * chartState.margin);

        if (isMouseNearLine(mouseY, triggerY)) {
          document.querySelectorAll('.trigger-menu').forEach(el => el.remove());

          const menu = document.createElement('div');
          menu.className = 'trigger-menu';
          menu.style.position = 'absolute';
          menu.style.left = `${e.pageX - 150}px`;
          menu.style.top = `${e.pageY - 10}px`;
          menu.style.backgroundColor = '#333';
          menu.style.color = 'white';
          menu.style.padding = '10px';
          menu.style.border = '1px solid #666';
          menu.style.borderRadius = '4px';
          menu.style.display = 'block';
          menu.style.zIndex = '1000';
          menu.style.pointerEvents = 'auto';
          menu.style.minWidth = '200px';

          menu.innerHTML = `
                    <div style="margin-bottom: 8px;"><strong>Trigger Details</strong></div>
                    <div>Type: ${trigger.type}</div>
                    <div>Price: ${trigger.price.toFixed(8)}</div>
                    <div>Status: ${trigger.status}</div>
                    <div class="trigger-menu-item" onclick="editTrigger(${trigger.id})">Edit</div>
                    <div class="trigger-menu-item" onclick="deleteTrigger(${trigger.id})">Delete</div>
                    <div class="trigger-menu-item" onclick="handleTriggerAction('connect', ${trigger.id})">Connect to Trade</div>
                    <div class="trigger-menu-item" onclick="showTradeOptions(${trigger.id})">Upon Trigger...</div>
                `;

          menu.addEventListener('mouseenter', () => {
            menu.dataset.hovering = 'true';
          });

          menu.addEventListener('mouseleave', function () {
            menu.dataset.hovering = 'false';
            menu.remove();
          });

          document.body.appendChild(menu);
        }
      });
    }
  }

  function moveTrigger(index, direction) {
    const triggers = window.currentTradeSetup.chainedTriggers;
    const newIndex = index + direction;

    if (newIndex >= 0 && newIndex < triggers.length) {
      [triggers[index], triggers[newIndex]] = [triggers[newIndex], triggers[index]];
      const updateSidebar = createTradeSetupSidebar();
      updateSidebar();
    }
  }

  function updateTriggerType(triggerId, newType) {
    const trigger = window.currentTradeSetup.chainedTriggers.find(t => t.id === triggerId);
    if (trigger) {
      fetch('/update-trigger', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          trigger_id: triggerId,
          updates: { type: newType }
        })
      })
        .then(response => response.json())
        .then(data => {
          // Get fresh trigger data from all_triggers
          const freshTrigger = all_triggers.find(t => t.id === triggerId);

          // Update local trigger data with fresh data
          Object.assign(trigger, freshTrigger);

          // Update trigger line on chart with fresh data
          const line = draw_lines.find(l => l.triggerId === triggerId);
          if (line) {
            line.type = freshTrigger.type;
            line.price = freshTrigger.price;
            line.timeframe = freshTrigger.timeframe;
            line.candles = freshTrigger.candle_count;

            // Force chart redraw
            drawCandlestickChart(stockData, start, end);
          }

          // Refresh sidebar
          const updateSidebar = createTradeSetupSidebar();
          updateSidebar();
        })
        .catch(error => console.error('Error updating trigger:', error));
    }
  }




  function updateTriggerTimeframe(triggerId, timeframe) {
    const trigger = window.currentTradeSetup.chainedTriggers.find(t => t.id === triggerId);
    if (trigger) {
      fetch('/update-trigger', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          trigger_id: triggerId,
          updates: { timeframe: timeframe }
        })
      })
        .then(response => response.json())
        .then(data => {
          // Update local trigger data
          trigger.timeframe = timeframe;

          // Refresh sidebar
          const updateSidebar = createTradeSetupSidebar();
          updateSidebar();
        })
        .catch(error => console.error('Error updating trigger:', error));
    }
  }

  function updateTriggerCandles(triggerId, candles) {
    const trigger = window.currentTradeSetup.chainedTriggers.find(t => t.id === triggerId);
    if (trigger) {
      fetch('/update-trigger', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          trigger_id: triggerId,
          updates: { candles: parseInt(candles) }
        })
      })
        .then(response => response.json())
        .then(data => {
          // Update local trigger data
          trigger.candles = parseInt(candles);

          // Refresh sidebar
          const updateSidebar = createTradeSetupSidebar();
          updateSidebar();
        })
        .catch(error => console.error('Error updating trigger:', error));
    }
  }


  function deleteTrigger(triggerId) {
    console.log("Chart: deleteTrigger", triggerId);
    fetch(`/delete-trigger/${triggerId}`, {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ trigger_id: triggerId })  // Properly format the request body
    })
      .then(response => {
        if (response.ok) {
          const index = current_triggers.findIndex(t => t.id === triggerId);
          if (index !== -1) {
            current_triggers.splice(index, 1);
          }
          drawCandlestickChart(stockData, start, end);
        } else {
          console.error('Chart: Failed to delete trigger');
        }
      })
      .catch(error => console.error('Error:', error));
  }

  function showTradeOptions(triggerId) {
    const trigger = current_triggers.find(t => t.id === triggerId);
    if (!trigger) return;

    // Remove any existing submenus
    document.querySelectorAll('.trigger-submenu').forEach(el => el.remove());

    const parentMenu = document.querySelector('.trigger-menu');
    const rect = parentMenu.getBoundingClientRect();

    const submenu = document.createElement('div');
    submenu.className = 'trigger-submenu';
    submenu.style.left = `${rect.right}px`;
    submenu.style.top = `${rect.top}px`;

    submenu.innerHTML = `
        <div class="trigger-submenu-item" onclick="handleTriggerAction('alert', ${triggerId})">Alert Only</div>
        <div class="trigger-submenu-item" onclick="handleTriggerAction('trade', ${triggerId})">Enter Trade</div>
    `;

    submenu.addEventListener('mouseenter', () => {
      submenu.dataset.hovering = 'true';
      parentMenu.dataset.hovering = 'true';
    });

    submenu.addEventListener('mouseleave', () => {
      submenu.dataset.hovering = 'false';
      submenu.remove();
    });

    document.body.appendChild(submenu);
  }

  function handleTriggerAction(action, triggerId) {

    const trigger = current_triggers.find(t => t.id === triggerId);
    console.log("Trigger:", trigger)

    switch (action) {
      case 'connect':
        if (!window.currentTradeSetup) {
          window.currentTradeSetup = {
            chainedTriggers: []
          };
        }

        // Check if trigger already exists in chain
        const exists = window.currentTradeSetup.chainedTriggers.some(t => t.id === trigger.id);
        if (!exists) {
          // Create complete trigger object with all database fields
          const triggerData = {
            id: trigger.id,
            product_id: trigger.product_id,
            type: trigger.type,
            price: trigger.price,
            timeframe: trigger.timeframe || '1m',  // Use actual DB value
            candles: trigger.candle_count || 1,    // Use actual DB value
            condition: trigger.condition,
            status: trigger.status
          };

          window.currentTradeSetup.chainedTriggers.push(triggerData);

          // Force sidebar update
          const updateSidebar = createTradeSetupSidebar();
          updateSidebar();

          // Open sidebar if closed
          if (document.getElementById('trade-setup-sidebar').style.right === '-350px') {
            toggleSidebar();
          }
        }
        break;

      case 'trade':
        // Enable line drawing mode for trade setup
        currentTool = 'line';
        window.currentTrade = {
          triggerId: trigger.id,
          entry: trigger.price,
          productId: selectedProduct.product_id
        };

        // Add trigger to currentTradeSetup
        window.currentTradeSetup = {
          trigger: trigger
        };

        // Show instructions for trade setup
        const instructions = document.createElement('div');
        instructions.className = 'trade-setup-instructions';
        instructions.style.position = 'fixed';
        instructions.style.top = '10px';
        instructions.style.left = '50%';
        instructions.style.transform = 'translateX(-50%)';
        instructions.style.backgroundColor = '#333';
        instructions.style.color = 'white';
        instructions.style.padding = '10px';
        instructions.style.borderRadius = '4px';
        instructions.style.zIndex = '2000';
        instructions.innerHTML = `
                <div>Draw lines for:</div>
                <div>1. Stop Loss (red)</div>
                <div>2. Profit Target(s) (yellow)</div>
                <div>Click Create Trade when done</div>
            `;
        document.body.appendChild(instructions);
        break;
    }
  }

  function showTradeSetupDialog(trigger) {
    const dialog = document.createElement('div');
    dialog.className = 'edit-trigger-form';
    dialog.style.position = 'absolute';
    dialog.style.left = '50%';
    dialog.style.top = '50%';
    dialog.style.transform = 'translate(-50%, -50%)';
    dialog.style.backgroundColor = '#333';
    dialog.style.padding = '20px';
    dialog.style.borderRadius = '8px';
    dialog.style.zIndex = '2000';

    dialog.innerHTML = `
        <h3>Trade Setup</h3>
        <div>
            <label>Size:</label>
            <input type="number" id="tradeSize" value="100">
        </div>
        <div>
            <label>Stop Loss (%):</label>
            <input type="number" id="stopLoss" value="1" step="0.1">
        </div>
        <div>
            <label>Take Profit (%):</label>
            <input type="number" id="takeProfit" value="2" step="0.1">
        </div>
        <div style="margin-top: 10px;">
            <button onclick="createTriggerTrade(${trigger.id})">Create</button>
            <button onclick="this.parentElement.parentElement.remove()">Cancel</button>
        </div>
    `;

    document.body.appendChild(dialog);
  }


  console.log("Current Exchange", exchange)
  console.log("Selected Product", selectedProduct.product_id)
  console.log("Fills", all_fills)
  // all_fills.forEach((fill)=> {
  //   console.log(fill.product_id, selectedProduct.product_id, fill.product_id == selectedProduct.product_id)
  // })
  console.log("Orders", all_orders)
  console.log("Current Fills", current_fills)
  console.log("Current Orders", current_orders)
  console.log("All Trades", all_trades)
  // console.log("Current Trades", current_trades)





  // --------------------------------------
  function connectToBackend() {
    const backendURL = "http://192.168.0.22:31337";
    console.log("Connecting to SSE at:", backendURL);

    const eventSource = new EventSource(`${backendURL}/trigger/stream`);

    eventSource.onopen = (event) => {
      console.log("SSE Connection opened:", event);
    };

    eventSource.onmessage = (event) => {
      try {
        const message = JSON.parse(event.data);
        switch (message.event) {
          case 'price':
            // console.log("Price:", message) // Passes Test
            updateChartPrice(message.data);
            break;
          case 'candle':
            // console.log("Candle:", message, "\nSelected_Product:", selectedProduct, "\nExchange:",exchange, selectedTimeframe) // Passes Test, need to filter out to only get the product_timeframe
            let parsed_product = `${selectedProduct.product_id}_${selectedTimeframe.TF}_${exchange.Name}`.toLowerCase().replace("-", "_")
            // console.log(parsed_product, message.data.ProductID)
            updateChart(message.data);
            break;
          case 'trigger':
            console.log("Trigger:", message);
            if (current_triggers) {
              // Find and update the triggered trigger
              const triggerIndex = current_triggers.findIndex(t => t.id === message.data.id);
              if (triggerIndex !== -1) {
                if (message.data.status === 'triggered') {
                  // Remove triggered trigger from array
                  current_triggers.splice(triggerIndex, 1);
                } else {
                  // Update trigger data
                  current_triggers[triggerIndex] = message.data;
                }
                // Redraw the chart to reflect the changes
                drawCandlestickChart(stockData, start, end);
              }
            }
            break;

        }
      } catch (err) {
        console.error("Error processing message:", err, "Raw data:", event.data);
      }
    };




    eventSource.onerror = (error) => {
      console.error("SSE connection error:", error);
      setTimeout(() => {
        console.log("Attempting to reconnect...");
        connectToBackend();
      }, 5000);
    };

    eventSource.addEventListener('candle', (event) => {
      try {
        const candleUpdate = JSON.parse(event.data)
        console.log("Raw Candle From Stream", event.data)
        console.log("Candle Update:", {
          product: candleUpdate.product_id,
          open: candleUpdate.Open,
          high: candleUpdate.High,
          low: candleUpdate.Low,
          close: candleUpdate.Close,
          volume: candleUpdate.Volume,
          time: new Date(candleUpdate.Timestamp * 1000).toLocaleTimeString(),
        })
        updateChart(candleUpdate)
      } catch (err) {
        console.error("Error processing candle update:", err)
      }
    })
  }

  function updateChartPrice(priceUpdate) {
    if (candleUpdate.product_id !== selectedProduct.product_id) {
      return
    }

    stockData.push({
      Timestamp: candleUpdate.timestamp,
      Open: candleUpdate.open,
      High: candleUpdate.high,
      Low: candleUpdate.low,
      Close: candleUpdate.close,
      Volume: candleUpdate.volume
    })

    if (stockData.length > end) {
      stockData.shift()
    }

    drawCandlestickChart(stockData, start, end)
  }

  function updateChartPrice(priceUpdate) {
    // console.log("Update Chart Price")

    if (priceUpdate.product_id !== selectedProduct.product_id) {
      return;
    }

    const latestPrice = priceUpdate.price;

    // Draw base chart first
    drawCandlestickChart(stockData, start, end);

    // Calculate price line position
    const width = canvas.width;
    const height = canvas.height;
    const margin = 50;

    const minPrice = Math.min(...stockData.slice(start, end).map(d => d.Low));
    const maxPrice = Math.max(...stockData.slice(start, end).map(d => d.High));

    const priceY = height - margin - ((latestPrice - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

    // Draw price line
    ctx.beginPath();
    ctx.moveTo(margin, priceY);
    ctx.lineTo(width - margin, priceY);
    ctx.strokeStyle = '#00ff00';
    ctx.setLineDash([5, 3]);
    ctx.stroke();
    ctx.setLineDash([]);

    // Add price label
    ctx.fillStyle = '#00ff00';
    ctx.font = '12px Arial';
    ctx.fillText(`${latestPrice.toFixed(5)}`, width - 100, priceY - 5);
  }

  function updateChart(candleUpdate) {
    // Convert underscores to dashes in ProductID
    const formattedProductID = candleUpdate.ProductID.replace(/_/g, '-');
    // console.log("|", candleUpdate.ProductID, "\n", selectedProduct)

    const newCandle = {
      Timestamp: candleUpdate.Timestamp,
      Open: candleUpdate.Open,
      High: candleUpdate.High,
      Low: candleUpdate.Low,
      Close: candleUpdate.Close,
      Volume: candleUpdate.Volume
    };

    // Check if candle with same timestamp exists
    const existingIndex = stockData.findIndex(candle => candle.Timestamp === candleUpdate.Timestamp);
    // console.log(existingIndex)

    if (existingIndex !== -1) {
      // Update existing candle
      stockData[existingIndex] = newCandle;
    } else {
      // Add new candle
      stockData.push(newCandle);

      // If we're at the end of the view, shift the window
      if (end === stockData.length - 1) {
        start++;
        end++;
      }
    }

    // Sort candles by timestamp to ensure proper order
    stockData.sort((a, b) => a.Timestamp - b.Timestamp);

    // Redraw chart with updated data
    drawCandlestickChart(stockData, start, end);
  }


  function showTriggerNotification(trigger) {
    const notification = document.createElement('div')
    notification.className = 'trigger-notification'
    notification.innerHTML = `
      <div class="notification-content">
        <strong>${trigger.product_id}</strong>
      </div>
    `
    document.body.appendChild(notification)

    setTimeout(() => notification.remove(), 5000)
  }

  function drawToolbar(ctx, width, height, margin, minPrice, maxPrice) {
    let activeLineIndex = -1;
    draw_lines.forEach((line, index) => {
      // Convert price back to Y coordinate
      const y = height - margin - ((line.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

      if (line.type === 'trigger') {
        ctx.setLineDash([5, 5])
      } else {
        ctx.setLineDash([])
      }

      ctx.beginPath();
      ctx.moveTo(margin, y);
      ctx.lineTo(width - margin, y);
      ctx.strokeStyle = line.color || 'yellow';
      ctx.stroke();

      ctx.fillStyle = 'white';
      ctx.font = '12px Arial';
      if (line.type === 'trigger') {
        const lastCandle = stockData[stockData.length - 1]
        const currentPrice = lastCandle.Close
        const triggerType = line.price > currentPrice ? 'Trigger Above' : 'Trigger Below'
        ctx.fillText(`${triggerType}: ${line.price.toFixed(8)}`, width - 200, y - 5)
      } else {
        ctx.fillText(`${line.type ? line.type + ' - ' : ''}${line.price.toFixed(2)}`, width - 120, y - 5);
      }
    });

    if (currentTool === 'line' && drawingStart) {
      ctx.beginPath();
      ctx.moveTo(margin, drawingStart.y);
      ctx.lineTo(width - margin, drawingStart.y);
      ctx.strokeStyle = 'yellow';
      ctx.stroke();
    } else if (currentTool === 'box' && drawingStart) {
      ctx.beginPath();
      ctx.rect(drawingStart.x, drawingStart.y, mouseX - drawingStart.x, mouseY - drawingStart.y);
      ctx.strokeStyle = 'yellow';
      ctx.stroke();
    }
  }

  function handleMouseMove(e, chartState, tradeGroups) {
    fillHoverHandler(e, chartState)
    orderHoverHandler(e, chartState)
    tradeHoverHandler(e, chartState, tradeGroups)
    lineHoverHandler(e, chartState)
    triggerHoverHandler(e, chartState)
  }

  canvas.addEventListener('mousemove', (e) => handleMouseMove(e, chartState, tradeGroups))

  canvas.addEventListener('mouseleave', function (event) {
    // console.log("Canvas Leave");

    // Get mouse position
    const mouseX = event.clientX;
    const mouseY = event.clientY;

    // Get canvas and menu boundaries
    const canvasRect = canvas.getBoundingClientRect();
    const menu = document.querySelector('.order-menu');
    const menuRect = menu ? menu.getBoundingClientRect() : null;

    // Check if mouse is still inside canvas or menu
    const isMouseInCanvas =
      mouseX >= canvasRect.left &&
      mouseX <= canvasRect.right &&
      mouseY >= canvasRect.top &&
      mouseY <= canvasRect.bottom;

    const isMouseInMenu =
      menuRect &&
      mouseX >= menuRect.left &&
      mouseX <= menuRect.right &&
      mouseY >= menuRect.top &&
      mouseY <= menuRect.bottom;

    if (!isMouseInCanvas && !isMouseInMenu) {
      // console.log("Mouse has left both canvas and menu");
      document.querySelectorAll('.order-menu').forEach(el => el.remove());
    }
  });

  function drawCandlestickChart(data, start, end) {

    // Set canvas size and clear
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Chart dimensions
    const width = canvas.width;
    const height = canvas.height;
    const margin = 50;
    const visibleData = data.slice(start, end);
    const candleWidth = (width - 2 * margin) / visibleData.length;

    // Price range
    const minPrice = Math.min(...visibleData.map(d => d.Low));
    const maxPrice = Math.max(...visibleData.map(d => d.High));

    // Draw candlesticks
    visibleData.forEach((d, i) => {
      const x = margin + i * candleWidth;
      const openY = height - margin - ((d.Open - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
      const closeY = height - margin - ((d.Close - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
      const highY = height - margin - ((d.High - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
      const lowY = height - margin - ((d.Low - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

      // Draw candlestick
      ctx.beginPath();
      ctx.moveTo(x + candleWidth / 2, highY);
      ctx.lineTo(x + candleWidth / 2, lowY);
      ctx.strokeStyle = 'gray';
      ctx.stroke();

      ctx.beginPath();
      ctx.rect(x, Math.min(openY, closeY), candleWidth, Math.abs(openY - closeY));
      ctx.fillStyle = d.Close >= d.Open ? 'gray' : 'gray';
      ctx.strokeStyle = 'black';
      ctx.fill();
      ctx.stroke();
    });

    // Draw fills
    if (current_fills) {
      current_fills.forEach(fill => {
        const fillTime = new Date(fill.time).getTime() / 1000;
        const firstCandleTime = visibleData[0].Timestamp;
        const timeRange = visibleData[visibleData.length - 1].Timestamp - firstCandleTime;
        const xPosition = margin + ((fillTime - firstCandleTime) / timeRange) * (width - 2 * margin);
        const fillY = height - margin - ((fill.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

        ctx.beginPath();
        ctx.arc(xPosition, fillY, 4, 0, 2 * Math.PI);
        ctx.fillStyle = fill.side.toLowerCase() === 'buy' ? 'lime' : 'red';
        ctx.fill();
      });
    }

    // Draw orders
    if (current_orders) {
      current_orders.forEach(order => {
        const orderY = height - margin - ((order.Price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
        ctx.beginPath();
        ctx.moveTo(margin, orderY);
        ctx.lineTo(width - margin, orderY);
        ctx.strokeStyle = order.Side.toLowerCase() === 'buy' ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255, 0, 0, 0.5)';
        ctx.stroke();
      });
    }

    // Draw trade groups
    tradeGroups = {};

    if (current_trades) {
      current_trades.forEach(trade => {
        if (!tradeGroups[trade.group_id]) {
          tradeGroups[trade.group_id] = [];
        }
        tradeGroups[trade.group_id].push(trade);
      });

      Object.values(tradeGroups).forEach(trades => {
        // Calculate Y positions for entry/stop/targets
        const entryY = height - margin - ((trades[0].entry_price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
        const stopY = height - margin - ((trades[0].stop_price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);
        const ptYs = trades.map(trade =>
          height - margin - ((trade.pt_price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin)
        );

        // Draw entry line
        ctx.beginPath();
        ctx.moveTo(margin, entryY);
        ctx.lineTo(width - margin, entryY);
        ctx.strokeStyle = trades[0].entry_status === 'FILLED' ? 'rgba(0, 255, 0, 0.8)' : 'rgba(0, 255, 0, 0.5)';
        ctx.stroke();

        // Draw stop loss line
        ctx.beginPath();
        ctx.moveTo(margin, stopY);
        ctx.lineTo(width - margin, stopY);
        ctx.strokeStyle = trades[0].stop_status === 'FILLED' ? 'rgba(255, 0, 0, 0.8)' : 'rgba(255, 0, 0, 0.5)';
        ctx.stroke();

        // Draw profit target lines
        trades.forEach((trade, i) => {
          const ptY = ptYs[i];
          ctx.beginPath();
          ctx.moveTo(margin, ptY);
          ctx.lineTo(width - margin, ptY);
          ctx.strokeStyle = trade.pt_status === 'FILLED' ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 255, 0, 0.5)';
          ctx.stroke();
        });

        // Draw connecting lines between targets
        ctx.beginPath();
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ptYs.forEach((ptY, i) => {
          if (i > 0) {
            ctx.moveTo(margin, ptYs[i - 1]);
            ctx.lineTo(width - margin, ptY);
          }
        });
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw R:R ratios
        trades.forEach((trade, i) => {
          const ptY = ptYs[i];
          const riskAmount = Math.abs(trade.entry_price - trade.stop_price);
          const rewardAmount = Math.abs(trade.pt_price - trade.entry_price);
          const rrRatio = (rewardAmount / riskAmount).toFixed(2);

          ctx.fillStyle = 'white';
          ctx.font = '12px Arial';
          ctx.fillText(`R:R ${rrRatio}`, width - 80, ptY - 5);
        });
      });
    }

    // Draw triggers
    if (current_triggers) {
      current_triggers.forEach(trigger => {
        // Skip triggered triggers
        if (trigger.status === 'triggered') {
          return;
        }

        const triggerY = height - margin - ((trigger.price - minPrice) / (maxPrice - minPrice)) * (height - 2 * margin);

        // Draw the trigger line
        ctx.beginPath();
        ctx.moveTo(margin, triggerY);
        ctx.lineTo(width - margin, triggerY);
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = '#b87100';
        ctx.stroke();
        ctx.setLineDash([]);

        // Add label
        ctx.fillStyle = 'white';
        ctx.font = '12px Arial';
        const triggerType = trigger.type 
        ctx.fillText(`${triggerType}: ${trigger.price.toFixed(8)}`, width - 200, triggerY - 5);
      });
    }



    // Add event listeners with chart state
    updateChartState(ctx, width, height, margin, minPrice, maxPrice)

    drawToolbar(ctx, width, height, margin, minPrice, maxPrice);
    drawCrosshair(ctx, width, height, margin, minPrice, maxPrice);

    return { ctx, width, height, margin, minPrice, maxPrice };
  }

  function isMouseNearLine(mouseY, lineY, threshold = 5) {
    return Math.abs(mouseY - lineY) < threshold;
  }


  function showLineMenu(x, y) {
    const menu = document.getElementById('lineMenu');
    const line = draw_lines[activeLineIndex];

    // Calculate line's Y position using stored chartState
    if (chartState) {
      const lineY = chartState.height - chartState.margin -
        ((line.price - chartState.minPrice) /
          (chartState.maxPrice - chartState.minPrice)) *
        (chartState.height - 2 * chartState.margin);

      menu.style.display = 'block';
      menu.style.left = `${x}px`;
      menu.style.top = `${lineY}px`;
    }
  }

  function cancelTrigger(triggerID) {
    fetch('/delete-trigger', {
      method: 'DELETE',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ trigger_id: triggerID })
    })
      .then(response => response.json())
      .then(data => {
        console.log('Trigger cancelled:', data)
        current_triggers = current_triggers.filter(triggers => triggers.id !== triggerID)
        drawCandlestickChart(stockData, start, end)
      })
      .catch(error => {
        console.error('Error cancelling trigger:', error);
      })
  }

  function hideLineMenu() {
    const menu = document.getElementById('lineMenu');
    menu.style.display = 'none';
  }

  // Fix calculatePrice function
  function calculatePrice(y, height, margin, minPrice, maxPrice) {
    return maxPrice - ((y - margin) / (height - 2 * margin)) * (maxPrice - minPrice);
  }
  function drawCrosshair(ctx, width, height, margin, minPrice, maxPrice) {
    // Draw vertical line
    ctx.beginPath();
    ctx.moveTo(mouseX, margin);
    ctx.lineTo(mouseX, height - margin);
    ctx.strokeStyle = 'rgba(100,100,100,0.5)';
    ctx.stroke();

    // Draw horizontal line
    ctx.beginPath();
    ctx.moveTo(margin, mouseY);
    ctx.lineTo(width - margin, mouseY);
    ctx.strokeStyle = 'rgba(100,100,100,0.5)';
    ctx.stroke();

    // Calculate price - fixed formula to match the candlestick scaling
    var price = minPrice + ((height - margin - mouseY) / (height - 2 * margin)) * (maxPrice - minPrice);
    ctx.fillStyle = 'white';
    ctx.fillText(price.toFixed(2), width - 40, mouseY - 5);
  }


  // Initial draw
  drawCandlestickChart(stockData, start, end);

  // Add event listeners for zooming and panning
  document.getElementById('chartContainer').addEventListener('wheel', function (event) {
    event.preventDefault();
    if (event.deltaY < 0) { // Zoom in
      if (end - start > zoomFactor) {
        start += zoomFactor;
        end -= zoomFactor;
      }
    } else { // Zoom out
      start = Math.max(0, start - zoomFactor);
      end = Math.min(stockData.length, end + zoomFactor);
    }
    drawCandlestickChart(stockData, start, end);
  });

  var isDragging = false;
  var startX;

  // Update mousedown event to store price instead of coordinates
  canvas.addEventListener('mousedown', function (event) {
    var rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;

    if (currentTool) {
      if (currentTool === 'line' || currentTool === 'trigger') {
        chartState = drawCandlestickChart(stockData, start, end);
        const price = calculatePrice(mouseY, chartState.height, chartState.margin, chartState.minPrice, chartState.maxPrice);
        const line = { price: price };

        if (currentTool === 'trigger') {
          const lastCandle = stockData[stockData.length - 1];
          const currentPrice = lastCandle.Close;

          line.type = 'trigger';
          line.color = '#ff00ff';

          const triggerData = {
            product_id: selectedProduct.product_id,
            type: line.price > currentPrice ? 'price_above' : 'price_below',
            price: parseFloat(line.price),
            status: 'active',
            xch_id: exchange.ID
          };

          fetch('create-trigger', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(triggerData)
          })
            .then(response => response.json())
            .then(data => {
              console.log('Trigger Created: ', data);
              line.triggerId = data.id;
            })
            .catch(error => {
              console.log('Error creating trigger:', error);
            });
        }

        draw_lines.push(line);
        drawCandlestickChart(stockData, start, end);
      }
      drawingStart = { x: mouseX, y: mouseY };
    } else {
      isDragging = true;
      startX = event.clientX;
      canvas.style.cursor = 'grabbing';
    }
  });

  // Fix the calculatePrice function
  function calculatePrice(y, height, margin, minPrice, maxPrice) {
    return maxPrice - ((y - margin) / (height - 2 * margin)) * (maxPrice - minPrice);
  }

  canvas.addEventListener('mouseup', function () {
    console.log("MouseUp")
    if (currentTool) {
      drawingStart = null
      if (currentTool === 'box') {
        console.log(" - _Box end", mouseX, mouseY)
      }
    } else {
      isDragging = false;
      canvas.style.cursor = 'crosshair';
    }
  });

  canvas.addEventListener('mouseleave', function () {
    // console.log("Canvas Leave2")
    isDragging = false;
    canvas.style.cursor = 'crosshair';
  });

  canvas.addEventListener('click', function (event) {
    console.log("Line Clicked", draw_lines)
    if (activeLineIndex >= 0 && draw_lines[activeLineIndex]) {
      showLineMenu(event.pageX, event.pageY);
      console.log("Line clicked - Price:", draw_lines[activeLineIndex].price);
      console.log("Line type", draw_lines[activeLineIndex].type)
      if (draw_lines[activeLineIndex].type) {
        console.log("Line type:", draw_lines[activeLineIndex].type);
      }
    }
  });

  canvas.addEventListener('mousemove', function (event) {
    var rect = canvas.getBoundingClientRect();
    mouseX = event.clientX - rect.left;
    mouseY = event.clientY - rect.top;


    if (isDragging) {
      var dx = event.clientX - startX;
      var panFactor = Math.floor(dx / 10);
      if (panFactor !== 0) {
        start = Math.max(0, start - panFactor);
        end = Math.min(stockData.length, end - panFactor);
        startX = event.clientX;
        drawCandlestickChart(stockData, start, end);
      }
    } else {
      drawCandlestickChart(stockData, start, end);
    }
  });

  // Redraw on window resize
  window.addEventListener('resize', function () {
    chartState = drawCandlestickChart(stockData, start, end);
  });

  document.getElementById('line').addEventListener('click', function () {
    console.log("Line Selected")
    if (currentTool == 'line' || currentTool == 'box') {
      currentTool = null
    }
    else {

      currentTool = 'line'
    }
  })
  document.getElementById('box').addEventListener('click', function () {
    if (currentTool == 'line' || currentTool == 'box') {
      currentTool = null
    }
    else {
      console.log("Box Selected")
      currentTool = 'box'
    }
  })
  document.querySelectorAll('.line-menu-item').forEach(item => {
    item.addEventListener('click', function (e) {
      const action = this.dataset.action;
      if (activeLineIndex >= 0 && draw_lines[activeLineIndex]) {
        const line = draw_lines[activeLineIndex];

        switch (action) {
          case 'trigger':
            const lastCandle = stockData[stockData.length - 1]
            const currentPrice = lastCandle.Close

            line.type = 'trigger';
            line.color = '%ff00ff';

            const triggerData = {
              product_id: selectedProduct.product_id,
              type: line.price > currentPrice ? 'price_above' : 'price_below',
              price: parseFloat(line.price),
              status: 'active',
              xch_id: exchange.ID
            }

            fetch('create-trigger', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(triggerData)
            })
              .then(response => response.json())
              .then(data => {
                console.log('Trigger Created: ', data)
                line.triggerId = data.id
              })
              .catch(error => {
                console.log('Error creating trigger:', error)
              })
            break;

          case 'entry':
            line.type = 'entry';
            line.color = '#00ff00';
            console.log("Entry line at price:", line.price);
            window.currentTrade = {
              entry: line.price,
              productId: selectedProduct.product_id
            };
            break;

          case 'pt':
            line.type = 'pt';
            line.color = '#ffff00';
            console.log("Profit target at price:", line.price);
            if (window.currentTrade && window.currentTrade.entry) {
              window.currentTrade.target = line.price;
            }
            break;

          case 'stop':
            line.type = 'stop';
            line.color = '#ff0000';
            console.log("Stop loss at price:", line.price);
            if (window.currentTrade && window.currentTrade.entry) {
              window.currentTrade.stop = line.price;
            }
            break;

          case 'delete':
            draw_lines.splice(activeLineIndex, 1);
            console.log("Line deleted at price:", line.price);
            break;

          case 'create':
            const entryLine = draw_lines.find(line => line.type === 'entry')
            const stopLine = draw_lines.find(line => line.type === 'stop')
            const targetLine = draw_lines.find(line => line.type === 'pt')

            if (!entryLine || !stopLine || !targetLine) {
              alert('Please set entry, stop loss, and profit target levels before creating trade')
              return
            }

            const tradeSetup = {
              entry: entryLine.price,
              size: 500,
              stop: stopLine.price,
              target: targetLine.price,
              productId: selectedProduct.product_id
            }
            createTradeGroup(tradeSetup)
            console.log("Trade group created", tradeSetup)
            break;
        }
      }

      hideLineMenu();
      drawCandlestickChart(stockData, start, end);
    });
  });

  function createTradeGroup(trade) {
    const side = trade.target > trade.entry ? 'BUY' : 'SELL';
    const riskAmount = Math.abs(trade.entry - trade.stop);
    const rewardAmount = Math.abs(trade.target - trade.entry);
    const riskRewardRatio = parseFloat((rewardAmount / riskAmount).toFixed(2));

    const ptLines = draw_lines.filter(line => line.type === "pt");
    const profitTargets = ptLines.map(line => parseFloat(line.price))

    const tradeData = {
      product_id: trade.productId,
      side: side,
      size: parseFloat(trade.size || "0"),
      entry_price: parseFloat(trade.entry),
      stop_price: parseFloat(trade.stop),
      profit_targets: profitTargets,
      risk_reward: riskRewardRatio,
      xch_id: exchange.ID,

    };

    fetch('/bracket-order', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(tradeData)
    })
      .then(response => response.json())
      .then(data => {
        console.log('Trade group created:', data);
      })
      .catch(error => {
        console.error('Error creating trade:', error);
      });
  }

  document.addEventListener('click', function (e) {
    if (!e.target.closest('#lineMenu') && !e.target.closest('#candlestickChart')) {
      hideLineMenu();
    }
  });

  document.getElementById('trigger').addEventListener('click', function () {
    if (currentTool === 'trigger') {
      currentTool = null;
    } else {
      currentTool = 'trigger';
      console.log("Trigger tool selected");
    }
  });


  drawCandlestickChart(stockData, start, end);
  document.addEventListener('DOMContentLoaded', () => {
    connectToBackend();

    // Initialize Bootstrap tabs if they exist
    const tabElements = document.querySelectorAll('[data-bs-toggle="tab"]');
    if (tabElements.length > 0) {
      tabElements.forEach(el => {
        new bootstrap.Tab(el);
      });
    }
  });

</script>
{{end}}